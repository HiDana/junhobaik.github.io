{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n기존 mac에 기본 내장된 apple-git을 사용하다 brew로 설치한 git으로 바꿨는데 갑자기 커맨드라인에서 한글로 안내, 에러 등.. 뜨기 시작했다.  \n그래서 방법을 알아보던중 alias를 변경하거나 하는 방법이 있는데 그건 여러 이유 때문에 그렇게 하는 건 곤란했고, 또한 ~/.bashrc를 건드는 방법들은 다 먹히지 않았다.\n\n그래서 알아낸 해법은 간단하다. iTerm 설정에서 profile - terminal으로 들어간다.  \n그리고 Set local variables automatically 이 선택되어있는 것을 비활성화해주면 된다.\n\n기본 터미널에도 동일한 설정이 있다, 똑같이 비활성화 해주면 된다.  \n설정 - 프로파일 - 고급 - 시작 시의 Locale 환경 변수를 설정\n","fields":{"slug":"/git-command-language/"},"frontmatter":{"title":"Git Command-line 언어가 갑자기 한글로 나올 때","published":true}}},{"node":{"rawMarkdownBody":"\n## GPG 키 생성하기\n\n우선 Homebrew 를 통해 gpg 패키지를 설치한다\n\n```shell\n$ brew install gpg\n```\n\n설치가 완료되면 아래 명령어를 통해 GPG Key 를 생성한다.\n\n```shell\n$ gpg --full-generate-key\n```\n\n아래 자세한 생성하는 과정이 나와있고, 간단히 요약하면 이러하다.\n\n- 암호화 방식 선택 (권장: 1)\n- 암호화 키 크기 선택 (권장: 4096)\n- 키 유효기간 설정 (권장: 0) // Enter 입력하여 패스\n- 이름, 이메일, 코멘트(공란 가능) 입력\n- 이후 보안 암호 문구 작성 창에서 암호 입력 (이후 첫 commit시 입력하는 암호로 쓰인다)\n\n```shell\nPlease select what kind of key you want:\n   (1) RSA and RSA (default)\n   (2) DSA and Elgamal\n   (3) DSA (sign only)\n   (4) RSA (sign only)\nYour selection? 1\n\n\nRSA keys may be between 1024 and 4096 bits long.\nWhat keysize do you want? (2048) 4096\n\n\nPlease specify how long the key should be valid.\n         0 = key does not expire\n      <n>  = key expires in n days\n      <n>w = key expires in n weeks\n      <n>m = key expires in n months\n      <n>y = key expires in n years\nKey is valid for? (0)\n\n\nGnuPG needs to construct a user ID to identify your key.\n\nReal name: Junho Baik\nEmail address: junhobaik@gmail.com\nComment:\nYou selected this USER-ID:\n    \"Junho Baik <junhobaik@gmail.com>\"\n\nChange (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O\n```\n\n위의 과정을 마치고 나면 키가 생성되었고,\n\n이제 아래 명령어(`gpg --list-secret-keys --keyid-format LONG`)를 이용하여 생성한 Public Key, Secret Key 를 확인한다.\n\n```shell\n$ gpg --list-secret-keys --keyid-format LONG\n\n-----------------------------------\nsec   rsa4096/ABCDE12345678900 2018-10-24 [SC]\n      AFWAEGWEGWAEDVADKAWGJIWRGLWJRGAIWALGRHRG\nuid                 [ultimate] Junho Baik <junhobaik@gmail.com>\nssb   rsa4096/AGRJIWGJWRGJIRWG 2018-10-24 [E]\n```\n\n위의 예제에서 `ABCDE12345678900` 부분을 복사하고 아래 명령어에 넣는다.\n\n```shell\n$ gpg --armor --export ABCDE12345678900\n```\n\n위 명령어를 입력한 후 나오는 키를 복사한다,  \n`-----BEGIN PGP PUBLIC KEY BLOCK-----`부터 `-----END PGP PUBLIC KEY BLOCK——.`를 포함해서 모두 복사하여야 한다.\n\n```shell\n -----BEGIN PGP PUBLIC KEY BLOCK-----\n\n // Key Code...\n\n -----END PGP PUBLIC KEY BLOCK-----.\n```\n\n## GitHub 에 GPG Key 등록\n\nGitHub - Settings - [SSH and GPG keys](https://github.com/settings/keys)\n\n위의 메뉴로 진입하여 GPG Keys 부분의 new GPG key 버튼을 클릭하고 복사한 키를 등록한다.\n\n## Git 에 GPG Key 등록\n\n아래 명령어를 통해 `~/.gitconfig`에 gpg 정보를 입력한다.\n\n여기서 `ABCDE12345678900`에 해당하는 것은 위에서 확인한 Key 부분이며, 본인의 것을 입력한다.\n\n```shell\n$ git config --global user.signingkey ABCDE12345678900\n```\n\n이제 등록이 되었고, 이후 commit 부터는 `-S` 플래그를 넣음으로 서명을 적용한 Commit 을 보낼 수 있다.\n\n```shell\n$ git commit -S\n```\n\n아래 명령어를 이용하면 `-S` 플래그를 번번히 넣지 않아도 항상 서명이 적용한 Commit 을 보내게 된다.\n\n```shell\n$ git config --global commit.gpgsign true\n```\n\n## Mac에서 Commit이 안될때\n\n1. pinentry-mac 설치 `$ brew install pinentry-mac`\n2. 1이 안될 시 GPG Suite 설치 [GPG Suite](https://gpgtools.org)\n\n---\n\n### References\n\n- [Generating a new GPG key](https://help.github.com/articles/generating-a-new-gpg-key/)\n- [GitHub 에서 GPG 서명하기 (for OS X)](https://medium.com/@Makart/github%EC%97%90%EC%84%9C-gpg-%EC%84%9C%EB%AA%85%ED%95%98%EA%B8%B0-for-os-x-4f45ad8f1a49)\n","fields":{"slug":"/github-gpg-key/"},"frontmatter":{"title":"GitHub에 GPG 서명 등록하기 (macOS)","published":true}}},{"node":{"rawMarkdownBody":"\n몇시간 전부터(현재 181023 04:41) github 가 이상하다,  \n5시간 전에는 로그인 부분이 이상이 있었다, 지금은 이부분은 해결되고 github page 를 업데이트해도 반영이 되지 않고 있다.  \n올해들어 세번정도 github 시스템 이상을 체험했던 것 같다...\n\n그럴 때 마다 들어가는 사이트가 있는데 github 에서 제공하는 github system status 페이지이다.  \n날자별 시스템 상태들이 어땠는지 확인 할 수 있고, 이상이 있을때는 어떻게 되어가는지 상황을 계속해서 업데이트해준다.\n\n--- \n\nGithub 의 시스템 상태는 아래 링크에서 확인 할 수 있다.\n\n[GitHub System Status](https://status.github.com/)\n","fields":{"slug":"/github-system-status/"},"frontmatter":{"title":"GitHub 서버 오류, 시스템 이상할 때 상태를 확인하기","published":true}}},{"node":{"rawMarkdownBody":"\n## 라디오 버튼의 스타일 바꾸기\n\n검색을 통해 쉽게 얻을 수 있는 라디오 버튼의 스타일 바꾸는 것은 대부분 :after, :before 를 사용하는데,  \n그렇게 되면 원하는대로 바꾸기가 쉽지 않고 원래의 개체가 노출되어 위치 조절을 해야하는 등 어려움이 있는데 아래 방법으로는 깔끔하고 원하는대로 가능하다.\ncss `appearence: none`을 시작으로 라디오 버튼을 수정하는 방법이다.\n\n### HTML\n\n```html\n<div class=\"radio-wrap\">\n  <input type=\"radio\" name=\"a\" id=\"a\"/>\n  <label for=\"a\">A</label>\n</div>\n\n<div class=\"radio-wrap\">\n  <input type=\"radio\" name=\"a\" id=\"a\"/>\n  <label for=\"a\">A</label>\n</div>\n```\n\n### CSS\n\n```css\ndiv.radio-wrap {\n  display: inline-flex;\n  align-items: center;\n}\n\ninput[type='radio'],\ninput[type='radio']:checked {\n  appearance: none;\n  width: 0.9rem;\n  height: 0.9rem;\n  border-radius: 100%;\n  margin-right: 0.1rem;\n}\n\ninput[type='radio'] {\n  background-color: $white-color;\n  border: 2px solid $font-color-3;\n}\ninput[type='radio']:checked {\n  background-color: $font-color-2;\n}\n```\n\n### 정리\n\n`input[type='radio'], input[type='radio']:checked`에 `appearance: none`을 함으로 모든 스타일이 제거된다.\n\n그렇게 되면 세로를 기준으로 가운데 정렬되어 텍스트와 나란히 있던 것이 무너지게 되고 그를 위해서\ndiv 로 감싸서 css 부분의 `div.radio-wrap{...}` 스타일 적용으로 가운데 정렬을 할 수 있다.\n\n`input[type='radio'], input[type='radio']:checked`에 라디오 버튼의 크기 및 `border-radius` 등 주고싶은 공통 스타일을 주고\n이제 각각의 `input[type='radio']`, `input[type='radio']:checked`에 원하는 색상, 테두리 등의 스타일을 적용해주면 된다.\n","fields":{"slug":"/radio-style-change/"},"frontmatter":{"title":"Radio Button의 색상 등 css를 바꾸기","published":true}}},{"node":{"rawMarkdownBody":"\n## 블로그 개편, use Gatsby\n\n기존 Jekyll을 이용 다른 사람의 테마를 사용하여 블로그를 운영해오고 있었습니다만  \nJekyll로 제작된 블로그를 마음대로 수정하기에는 루비라던가 익숙하지 않은 것이 많아 고민이었는데 마침 Gatsby라는 정적 사이트 제작 프레임워크를 찾았고 개편을 마음 먹었습니다.\n\nGatsby는 **React**와 **Webpack**을 베이스로 제작되어서 그 점이 가장 마음에 들었고 편리하게 사이트를 구축하기 위한 Plugin도 많이 제공되고 있었습니다.  \n비록 테마나 구글링을 통해 얻을 수 있는 정보는 Jekyll보다 많이 부족하지만 애초에 테마가 아닌 처음부터 직접 구현하고 싶었기에 큰 문제는 아니었습니다.\n\n일단 시작은 Gatsby에서 제공하는 기본 starter인 [gatsby-starter-default](http://gatsbyjs.github.io/gatsby-starter-default/)\n를 clone하여 비어있는 화면 부터 시작했고 천천히 개발하기 시작하여 지금 이러한 블로그로 개발하였습니다.\n\n\n### Built With:\n\n개발에 사용된 기술은 크게 아래와 같습니다.\n\n- Gatsby.js\n- React\n- Webpack\n- GraphQL\n- SASS(SCSS)\n- typography\n\n### 후기\n\n`GraphQL`  \n지금까지 개발면서 일단 처음에 GraphQL을 접하면서 모르는 것이기도 했고 인터넷에 정보도 부족해 시작이 어려웠습니다. 끼워맞추듯 개발하며 이해하다보니 지금도 모르는 상태라고 할 수 있지만 조만간 제대로 한번 배워볼 예정입니다.\n\n`Theme?`  \n혼자 사용하는 것이 아닌 모두 사용할 수 있게 테마 형식으로 제작해 보려 합니다. 아직은 디테일한 기능들을 구현할게 남았고 그 이후에 코드 최적화를 하면서 개인화하여 쓸 수 있도록 수정할 예정입니다.\n\n`반응형 웹사이트`\n기존에도 항상 반응형으로 제작을 하긴 했지만 이번엔 여러모로 테스트를 하다 보니 쉽지 않다는 것을 다시금 느꼈습니다. 쉽게 orientation으로만 하려고 했더니 안드로이드에서는 가상 키보드가 나오면서 키보드가 차지한 부분이 감소되며 세로 비율이었던 orientation이 가로로 바뀌게 되어 모바일에 최적화된 화면에서 데스크탑 최적화된 화면이 출력되게 되는 문제를 겪기도 했습니다.\n\n`SEO, 웹표준`  \n기존의 Jekyll은 테마를 받아 사용하다보니 검색최적화나 Google Analytics가 다 적용된 상태였습니다만 이번에 처음부터 개발하다보니 웹표준과 SEO에 대해서도 신경쓰면서 하게 되었습니다.  \n\n- 웹사이트 점수 측정 100/100 [확인하기](https://website.grader.com/results/junhobaik.github.io)\n- NAVER 웹마스터 사이트 최적화 '최고에요' 등급\n\n웹표준에 관해서는 아직 부족한 게 많은 것 같으니 공부하고 수정해야 할 것 같고, SEO부분에 대해서는 구현을 마쳤고 이번에 많이 알게되었습니다.\n\n### Github\n\n[Github Repository](https://github.com/junhobaik/junhobaik.github.io)\n","fields":{"slug":"/new-blog-notice/"},"frontmatter":{"title":"블로그 개편 (Jekyll -> Gatsby)","published":true}}},{"node":{"rawMarkdownBody":"\n## ₩ -> `\n코드를 작성하거나 마크다운 문서를 작성할때 한글키 입력 상태일때 키보드의 (~`)키를 누르면 ₩가 입력되는 것이 별거 아닌 것 같지만 상당히 불편한 요소로 작용합니다.\n\n생각보다 원화(₩) 문자를 쓸 일이 없으므로 아예 백쿼트(`) 문자가 입력되도록 바꿔보도록하겠습니다.\n\n방법은 아래 블로그를 참고하였습니다.\n\n[A2 Devlog](https://ani2life.com/wp/?p=1753)\n","fields":{"slug":"/mac-keybind-won-bq/"},"frontmatter":{"title":"mac의 한글키에서 원화(₩)가 아닌 백쿼트(`)가 입력되도록 하기","published":true}}},{"node":{"rawMarkdownBody":"\nAngular 개발을 시작하기 전, 개발에 앞서 개발 환경 구성과 간단한 사용을 먼저 해보자.\n\n\n## TypeScript\n\nAugular를 본격적으로 하기 전 TypeScript를 설치하기로 하자.\n\n타입스크립트는 동적 타입 언어인 자바스크립트에 명시적으로 타입 선언이 가능하도록 정적 타입 언어의 장점을 가지게 된 언어이다.  \n\nAngular(!= AngularJS)는 TypeScript를 베이스로 만들어졌고,  \n왜 앵귤러에 타입스크립트인지는 아래 링크의 글을 읽어보면 좋을 것이다.\n\n[Angular: Why TypeScript](https://github.com/not-for-me/til/blob/master/angular2/translations/writing_angular2_in_typescript.md)\n\n### 설치\n\n아래 명령어를 사용하여 타입스크립트를 설치하자.\n\n```shell\n$ npm install -g typescript\n```\n\n글로벌 설치를 선호하지 않는다면 프로젝트내 설치하는 방법도 물론 괜찮다.\n\n글로버 설치를 했다면 이제 `tsc test.ts`와 같이 명령어로 타입스크립트를 컴파일 할 수 있다.\n\n만약 프로젝트 내 설치를 했다면 npm script에서 `\"tsc test.ts\"` 와 같이 스크립트를 추가하거나, \n콘솔 환경에서 `node_modules/.bin/tsc test.ts`와 같이 컴파일이 가능하다.\n\n아래 기술하는 내용들은 글로벌 설치를 전제로 설명하게 된다.\n\n### 설정\n\n```shell\n$ tsc --init\n```\n\n이제 프로젝트 내에서 위 명령어로 설정 파일(`tsconfig.json`)을 생성할 수 있다.\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"commonjs\",\n      ...\n```\n\n어떤 자바스크립트 버전으로 컴파일 할건지 등 설정 파일 안에는 다양한 설정이 가능한데 앵귤러 개발 환경 구성 포스팅이므로 자세한 설정 방법은 생략하겠다.\n\n### TSLint\n\n추가적으로 TSLint를 사용하여 Lint 기능을 사용하는 것도 좋은 방법이다.\n\nnpm으로 설치하거나, Visual Studio Code와 같이 타입스크립트와 호환이 좋은 에디터에서 TSLint를 사용하면 좀 더 판하게 개발 할 수 있다.\n\n### 간단한 사용\n\n자바스크립트를 쓰는 것과의 차이점을 위해서 매우 간단한 예제를 살펴보자.\n\n```javascript\nconst n = 1;\nconst s = '1';\n\nconsole.log(n == s);\n```\n숫자 1과 문자 1을 비교하는 (Strict 비교 아님) 코드가 있고\n\n만약 이것이 자바스크립트 파일(.js)라고 가정하면 결과는 **true**가 될 것이다.  \n그리고 이것이 타입스크립트 파일(.ts)라고 가정하면 아래와 같은 결과를 얻을 수 있다.  \n\n우선 TSLint가 `==`가 아닌 `===`를 사용하라고 알려줄 것이고,  \n그리고 무시하고 컴파일을 진행한다면 아래와 같은 에러가 발생한다.\n\n```shell\nerror TS2365: Operator '==' cannot be applied to types '1' and '\"1\"'.\n```\n\n숫자와 문자열을 비교할 수 없다는 의미이다.\n\n클래스 등 좀 더 다양한 예제는 아래 링크에서 확인하면 좋다.\n\n[TypeScript PlayGround](http://www.typescriptlang.org/play/)\n\n\n\n\n\n\n\n## Angular CLI\n\n### 설치 및 프로젝트 생성\n\nAngular CLI를 이용해 앵귤러 개발을 시작하는 방법이다.\n\n```shell\n$ npm install @angular/cli -g\n$ ng --version\n```\n\n`ng new` 명령어를 통해 기본적인 코드와 설정이 되어있는 앵귤러 프로젝트를 생성할 수 있다.\n\n```shell\n$ ng new auglar-start-cli\n$ cd angular-start-cli\n```\n\n### 개발 서버\n\n이제 이렇게 생성된 프로젝트에서 아래 명령어를 통해 로컬 개발 서버를 켤 수 있다.\n\n```shell\n$ ng serve\n** Angular Live Development Server is listening on localhost: 4200, open your browser on http://localhost:4200/ **\n```\n\n그리고 출력된 주소로 가서 정상적으로 출력이 되고 있는지 확인해보자.\n\n### 기타 명령어\n\n생성된 프로젝트에서 컴포넌트 및 서비스를 생성한다면 직접 하는 방법도 있지만,  \nAngular CLI의 기본 구조대로 뷰, 컴포넌트(or Service), 스타일, 테스트 파일을 생성해주는 명령어가 있다.\n\n```shell\n# 컴포넌트 생성\n$ ng generate component COMPONENT_NAME\n# 서비스 생성\n$ ng g service SERVICE_NAME\n# generate는 g로 줄여 사용할 수 있다.\n```\n\n예로 이렇게 생성된 컴포넌트는 아래와 같은 구조를 가진다\n```javascript\n- home\n  - home.component.html // View\n  - home.component.ts // Component\n  - home.component.spec.ts // Test\n  - home.component.css // Style\n```\n\n---\n\n## References\n- 서적 '앵귤러 첫걸음' 한빛소프트\n- [Angular official](https://angular.io/guide/quickstart)\n","fields":{"slug":"/angular-setup/"},"frontmatter":{"title":"Angular 시작하기 (개발 환경 구성)","published":true}}},{"node":{"rawMarkdownBody":"\ncolors 모듈은 우리가 흔히 사용하는 `console.log`의 출력문에 색상을 입힐 수 있다.\n\n## 설치\n\n```shell\nnpm install --save colors\n```\n\n## 사용하기\n\n```javascript\nconst colors = require(\"colors\");\n```\n\n기본적인 사용.\n\n```javascript\nconsole.log(\"hello world\".red); // 빨간색 글씨\nconsole.log(\"hello world\".underline); // 밑줄\nconsole.log(\"hello world\".underline.blue); // 밑줄있는 파란색 글씨\nconsole.log(\"hello world\".inverse.yellow); // 배경이 노란색인 검정 글씨\nconsole.log(\"hello world\".rainbow); // 무지개색 글씨\nconsole.log(\"hello world\".trap); // 알아보기 힘든 모양의 글씨 (ƕɘĹĹʘ ШǾ®Ĺԁ)\n```\n\n아래와 같은 사용도 가능하다.\n\n```javascript\nconsole.log(colors.green(\"hello world\")); // 초록색 글씨\n```\n\n아래와 같은 방식으로 커스텀 테마를 지정해 사용할 수도 있다.\n\n```javascript\ncolors.setTheme({\n  error: 'red',\n  warn: 'yellow',\n});\n\nconsole.log('ERROR!'.error); // 빨간색 글씨\nconsole.log('Warning.'.warn); // 노랜색 글씨\n```\n\n```javascript\ncolors.setTheme({\n  test: ['blue', 'inverse']\n});\n\nconsole.log('testing'.test); // 파란색 배경의 검정 글씨\n```\n","fields":{"slug":"/colors-module/"},"frontmatter":{"title":"콘솔에 색상을 입혀주는 'Colors' 모듈 사용해보기","published":true}}},{"node":{"rawMarkdownBody":"\n처음 html, javascript를 공부 할 때는 script 태그는 head 태그에 위치하게끔 하는 코드나,  \n또는 body 태그의 어디에 위치하건 그 위치에 대해 별 의미를 두지 않는 코드들이 많았다.\n\n하지만 지금은 항상 스크립트는 body태그의 최하단에 넣는 것이 습관화되었고 그 이유도 알고 있다.  \n그런데 이제와서 이 글을 쓰는 이유는 **script 태그의 async / defer**를 공부하게 되면서 새로 정리해보고자 쓰게 되었다.\n\n## 브라우저의 동작과 script 위치의 2가지 이유\n\nHTML에서 script 태그가 body 태그 안의 최하단에 위치해야 하는 이유는 브라우저의 동작 방식과 연관이 있다.\n\n1. HTML을 읽기 시작한다.\n2. HTML을 파싱한다 (parsing: 컴퓨터가 읽을 수 있는 코드로 바꾸는 작업)\n3. DOM 트리 생성.\n4. Render 트리가 생성 (DOM tree + CSS의 CSSOM 트리 결합)\n5. Display(브라우저)에 표시된다.\n\n여기서 중요하게 봐야할 구간은 1~2의 과정이다.\n\nHTML을 읽어 내려가는 과정에서 script 요소를 만나면 파싱을 중단,  \n중단 된 상태에서 자바스크립트 코드(파일)을 로드 후 자바스크립트 코드를 파싱한다.  \n그리고 다시 HTML 파싱이 계속된다.\n\n결론적으로 HTML을 읽는 과정에서 자바스크립트 로드와 파싱을 위해서 중단되는 시점이 생기고,\n그에 따라 그 만큼 Display에 표시되는 것이 지연된다.\n\n**위의 경우가 body태그 최하단에 위치해야 하는 이유 1번째이다.**\n\n2번째 이유는, **HTML 파싱이 끝나고 DOM 트리가 생기기 전 자바스크립트가 DOM 조작을 할 경우 에러 발생**이 할 수 있다는 것이다.\n\n```javascript\nconst appEl = document.querySelector(.app);\n```\n\n우리는 위와 같이 DOM에 관한 조작을 무수히 할 것인데 DOM 트리가 렌더링 되기 전이라면 `appEl`은 `undefined`이다. 이러한 오류점이 발생한 이유를 모르거나, 디버깅을 못한다면 이를 해결하는데 꽤나 애먹을 것이다.\n\n이렇게 body 태그 최하단에 위치해야하는 이유를 알아봤고 다음으로는 이러한 이유를 방지하기 위해서 사용하는 **script 태그의 async / defer 속성**을 알아보자.\n\n## script 태그의 async / defer 속성\n\n기본적으로 script 태그는 위에서 작성한 브라우저의 동작 방식대로 불러진다.  \n하지만 async / defer 속성을 사용함으로 다르게 script 태그를 불러올 수 있게 된다.\n\n```html\n<script async src=\"index.js\"></script>\n<script defer src=\"index.js\"></script>\n```\n\nasync / defer 속성을 사용하면 **HTML 파싱과 동시에 스크립트 로드**가 이루어진다.\n\n그 후에,  \n**async**의 경우에는 **스크립트 로드가 완료되는 즉시 스크립트가 실행**된다.  \n**defer**의 경우에는 **HTML 파싱이 모두 끝난 뒤 스크립트가 실행**된다\n\n결론적으로,  \n\n**async / defer**를 사용함으로 HTML 파싱과 스크립트 로드가 동시에 진행되므로 **HTML 파싱이 완료되는 시간을 줄일 수 있다**  \n\n**async**는 파싱 완료 전에 스크립트 로드 후 실행이 되므로 위에서 body태그 최하단에 script 태그가 위치해야하는 2번째 이유에 적합하지 않다.  \n\n**defer**는 파싱이 완료 된 후 스크립트가 실행되므로 2가지 이유 전부에 적합하다.\n\n---\n\n## References\n- [PoiemaWeb](http://poiemaweb.com/js-syntax-basics)\n","fields":{"slug":"/js-script-position/"},"frontmatter":{"title":"HTML에서 script태그는 어디에 위치해야 할까?","published":true}}},{"node":{"rawMarkdownBody":"\n\n기존 Jekyll을 이용한 블로그는 현재(2018.09) Gatsby를 이용한 블로그로 개편되었습니다.  \nJekyll의 minimal-mistakes테마를 이용한 블로그를 만들고 싶다면 아래 게시물은 아직 유효합니다.\n\n---\n\n[Jekyll 블로그 테마 적용하기 (minimal-mistakes)](https://junhobaik.github.io/jekyll-apply-theme/)  \n위 포스트를 먼저보시기를 추천드립니다.  \n위 포스트를 보고 어려움을 느끼거나 더 쉽게 적용하고 싶은 분들을 위한 방법을 적은 포스팅입니다.\n\n---\n\n~~이제 지금 보고 계시는 블로그가 맘에 들고 그대로 사용하시고 싶다,~~  \n~~이 블로그를 그대로 가져와 편집해 사용하고 싶다,~~  \n또는 기존의 테마 적용 포스트가 너무 어렵다.\n\n이러한 분들이 사용 할 수 있도록\n지금의 블로그에서 포스트들을 제거하고 개인 설정을 초기화 한 것을 준비해두었고\n그것을 받아서 개인 설정만 채워주면 사용 할 수 있는 방법을 소개합니다.  \n(지금 보고 있는 블로그와 차이가 있을 수 있습니다,\n2018.04 시점의 블로그를 기준으로 합니다.)\n\n일단 jekyll가 설치 되어있고 Github 계정이 필요하며,\n여기에 대한 것은 생략하고 테마 적용 부분에 대해서만 기술하습니다.  \n참고 : [Jekyll 블로그 시작하기 (MacOS, GitHub Page)](https://junhobaik.github.io/start-jekyll-blog/)\n\n\n## 적용하기\n\n[junhobaik/junhobaik.github.io](https://github.com/junhobaik/junhobaik.github.io)\n\n우선 위의 링크로 들어가 우측 상단의 Fork 버튼을 눌러 Fork 합니다.\n\n그렇다면 자신의 계정에 `junhobaik.github.io` 리포지토리가 생기게 되고,  \n리포지토리 페이지에서 `clone or download`에서 링크를 확인합니다 (ex. https://github.com/username/junhobaik.github.io.git)\n\n이제 terminal을 열고 clone 과 동시에 필요한 작업을 합니다.\n\n```shell\n# 아래 링크는 위에 clone or download에서 확인한 링크를 넣는다.\n$ git clone https://github.com/username/junhobaik.github.io.git blog\n$ cd blog\n$ git reset origin/dev --hard\n$ npm install\n# bundle 명령어 수행 시 sudo 권한으로 컴퓨터 비밀번호를 요구 할 수 있습니다.\n$ bundle\n$ git push -f\n```\n\n이제 다시 해당 리포지토리 페이지에 들어가서 Settings으로 들어갑니다.\n\nRepository name을 username.github.io로 변경합니다.  \n(여기서 username은 자신의 github username을 입력합니다.)\n\n리포지토리 이름이 변경된 것을 확인하시고,\n다시 설정 페이지에서 'GitHub Pages'란을 확인합니다.\n여기에 `Your site is published at https://username.github.io/` 라는 초록색 배경의 문구가 나왔다면 정상적으로 적용 된 것입니다. \n\n이제 해당 주소로 블로그를 볼 수 있습니다.  \n해당 주소에서 에러 페이지를 만난다면 약간의 시간이 필요할 수 있으니 조금만 기다려보세요.\n\n여기까지 하셨다면 [Jekyll 블로그 테마 적용하기 (minimal-mistakes)](https://junhobaik.github.io/jekyll-apply-theme/) 해당 포스트에서 **테마 설정하기**에서 **테마 스킨**부터 **댓글 설정**까지 개인 설정을 적용해주면 이제 포스트를 작성하고 블로그를 시작하면 됩니다.\n","fields":{"slug":"/jekyll-apply-theme-simple/"},"frontmatter":{"title":"Jekyll 블로그 테마 '쉽게' 적용하기 (minimal-mistakes)","published":true}}},{"node":{"rawMarkdownBody":"\nJavascript Hoisting에 대해 다시 살펴보던 도중, 예전에 공부할땐 var를 대상으로 공부했으니 깨닫지 못했는데 이번에 let, const를 가지고 해보니...  \n호이스팅이 되지 않았다. (정확히 말하면 호이스팅이 되지 않는 것은 아니다.)\n\n그래서 이제 어떻게 된건지 알아보자. (Hoisting의 개념과 Block-Scope 개념을 기본적으로 알고 있어야 이해가 가능하다.)\n\n## 기존의 Hoisting\n\n```javascript\nconsole.log(a);\nvar a = 10;\n```\n\n호이스팅 후 =>\n\n```javascript\nvar a;\nconsole.log(a); // undefinded\na = 10;\n```\n\n호이스팅이 적용된 코드는 위와 같고 따라서 undefinded가 출력된다.\n\n## let, const의 Hoisting\n\n```javascript\nconsole.log(a);\nlet a = 10;\n```\n\n이렇게 let으로 바꾼다면 결과는\n\n```shell\nUncaught ReferenceError: a is not defined\n```\n\n위와 같은 a가 정의되지 않았다는 레퍼런스 에러가 발생한다,  \n결국 a 변수 선언이 위로 호이스팅되지 않았다는 이야기가 된다.\n\n하지만 그렇지 않다.\n아래 예제를 보면 호이스팅이 안되는게 아니라는 것을 알 수 있다.\n\n```javascript\nlet a = 10;\n\n{\n  console.log(a);\n}\n```\n\n위 예제는 당연하게도 `10`이 출력된다.\n이제 아래 예제를 보자\n\n```javascript\nlet a = 10;\n{\n  console.log(a);\n  let a = 20;\n}\n```\n\n호이스팅이 되지 않는다면 위 코드 그대로 실행되어 10이 출력되는 것이 정상일 것이다.  \n그러나 여기서는 아래와 같이 에러가 출력된다.\n\n```shell\nUncaught ReferenceError: a is not defined\n```\n\n결국 let, const와 같이 ES6 선언도 호이스팅의 대상이기 때문에 위에서는 두번째 let의 블록 스코프안에서 호이스팅이 이뤄서 console.log에서 에러가 발생하게 된 것이다.\n\n그렇다면 이러한 에러가 발생하는 이유는 무엇일까,\n\n우선 var 키워드의 경우를 살펴보자,  \n```javascript\nvar a = 10;\n```\nvar로 선언된 변수는  \n[선언 - 초기화 - 할당] 의 단계 중  \n[선언 - 초기화]가 한번에 이루어지고 다음에 [할당]이 되게 된다.\n\n1. [선언 - 초기화]\n2. [할당]\n\n그에 반해 let/const 키워드는 다르게 실행된다.  \n선언, 초기화, 할당이 따로 이루어지고 **TDZ(Temporal Dead Zone)**라는 것이 개입한다.\n\n과정은 아래와 같다.\n\n1. [선언]\n2. [TDZ]\n3. [초기화]\n4. [할당]\n\n초기화(변수가 메모리에 할당되며 undefined로 초기화되는 과정)가 되기 전에 변수에 접근하려 한다면 **TDZ**에 의해서 에러가 발생하게 된다.\n\n```javascript\nvar a;\nconsole.log(a);\na = 10;\n```\n```javascript\nlet a;\nconsole.log(a);\na = 10;\n```\n\n위처럼 호이스팅 된 코드를 보면 변수에 접근하는 데 있어  \n기존 var 키워드는 선언과 초기화가 함께 되었으므로 접근하여도 정상적으로 undefined가 출력된다.  \n하지만 let/const 키워드는 선언만 호이스팅 되고 그것은 초기화 이전이므로 접근하려 한다면 TDZ에 의해서 에러가 발생하는 것이라고 볼 수 있다.\n\n여기까지 let/const의 관점에서의 Hoisting에 대해 포스팅해보았다.  \nlet/const를 사용하면서 조금 더 엄격한 자바스크립트를 작성할 수 있게 되었고 그로 인해 예기치 않은 오류를 작성하는 상황을 줄일 수 있게 된 것 같다.\n\n---\n\n## References\n\n- [let, const와 블록 레벨 스코프](http://poiemaweb.com/es6-block-scope)\n- [let과 const는 호이스팅 될까?](https://medium.com/korbit-engineering/let%EA%B3%BC-const%EB%8A%94-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EB%90%A0%EA%B9%8C-72fcf2fac365)\n","fields":{"slug":"/js-let-cont-hoisting/"},"frontmatter":{"title":"ES6, Hoisting으로 다시 보는 let, const","published":true}}},{"node":{"rawMarkdownBody":"\n[**Netflix AutoSkip**][1]\n\n넷플릭스 인트로, 줄거리 자동 스킵  \n다음 에피소드 재생 대기 시간 없이 바로 재생\n\n---\n\n넷플릭스를 런칭때부터 쭈욱 쓰던 입장으로 항상 불편했던 것이 있는데,  \n인트로 영상이 자동으로 스킵되지 않는다는 것이다. 스킵 버튼이 있긴하지만 수동으로 눌러줘야 한다.  \n그리고 정주행을 하면서 한 에피소드가 끝나고 다음 에피소드 재생까지는 대기 시간 5초 또는 15초가 있는데 정주행에선 그 것 조차 기다리기 싫을때가 있다.\n\n얼마 전 부터는 영상의 맨 처음이 줄거리나 인트로인 경우엔 그 다음 부터 재생이 되는 경우도 있지만  \n대부분이 에피소드가 시작하고 얼마 후에 인트로가 나오는 형식이기에 인트로가 긴 경우에는 멀리서 시청할 경우 컴퓨터 앞까지 가서 스킵 버튼을 누르곤 했다.\n\n그 불편함을 없애기 위해 간단한 프로그램을 하나 만들었다.\n\n---\n\n기능은 간단하다.\n\n- 인트로, 줄거리 스킵 버튼을 자동으로 눌러지게 한다.\n- 다음 에피소드 재생 버튼을 자동으로 눌러지게 한다.\n\n설정을 통해 각 스킵 설정들을 온오프할 수 있다.\n\n---\n\n다운로드는 아래 링크를 통해 가능하다.\n\n[Netflix AutoSkip 크롬 웹스토어 바로가기][1]\n\n\n[1]: https://chrome.google.com/webstore/detail/pfcombngcgnehkbdoafkhdcfdmklboai\n","fields":{"slug":"/netflix-autoskip/"},"frontmatter":{"title":"넷플릭스 정주행을 위한 인트로 자동 스킵 크롬 확장 프로그램 (Netflix AutoSkip)","published":true}}},{"node":{"rawMarkdownBody":"\n주로 CRA(create-react-app)을 이용한 리액트 개발을 주로 해왔고 그로 인해 웹팩(Webpack) 번들러를 통해 간단한 설정 변경 등을 해왔는데 이번에 새로운 번들러인 파셀(Parcel)을 알게되었다.\n\n공식 홈페이지의 헤드라인부터 **불꽃 튀게 빠르고 설정이 필요 없는 웹 애플리케이션 번들러**이다.  \n사용해보고나니 비교적 무거운 웹팩보다는 빠르다는게 느껴졌고 복잡했던 설정법보다는 쉽게 설정이 가능한 번들러였다. minify, hot module replacement와 같이 기본적으로 필요한 기능은 거의 포함되어있고 가벼우니 개인 소규모 프로젝트에는 좋을 것 같다는 생각이 들었다.\n\n\n\n## Parcel 시작하기\n\n[공식 홈페이지](https://parceljs.org/)\n\n일단 파셀을 사용하기 위해 글로벌 설치해보자\n```shell\n$ npm install -g parcel-bundler\n```\n\n다음으로 우선 git과 npm을 init하자\n```shell\n$ git init\n$ npm init\n```\n\n`index.html`, `index.js` 파일을 준비하고\n```html\n<!-- index.html -->\n<body>\n  <div id=\"root\"></div>\n  <script src=\"./index.js\"></script>\n</body>\n```\n위와 같이 js파일을 연결해준다.  \ndiv#root는 후에 React를 사용하기 위한 것이다.\n\n그리고 파셀 명령어로 개발 서버를 켜주면 파셀을 사용할 준비가 된 것이다.\n\n```shell\n$ parcel index.html\n\nServer running at http://localhost:1234\nBuilt in 9ms.\n```\n\nNPM Script에도 추가해두면 편리하게 사용이 가능하다.\n```json\n// package.json\n  \"scripts\": {\n    \"start\": \"parcel index.html\"\n  }\n```\n\n\n\n## React 사용하기\n\nReact 사용은 Parcel이라고 다르지 않으므로 간단히 다루겠다.\n\n```\n$ npm install --save react react-dom\n```\n\n이제 리액트 컴포넌트와 css파일을 만들고 index.js를 수정해보자\n\n`./src/App.js`\n```javascript\nimport React from 'react';\nimport './style.css';\n\nclass App extends React.Component {\n  render(){\n    return(\n      <div id=\"App\">\n        Hello World\n      </div>\n    )\n  }\n}\n\nexport default App;\n```\n\n`./src/style.css`\n```css\nbody {\n  color: red;\n}\n```\n\n`./index.js`\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './src/App.js';\n\nReactDOM.render(<App />, document.getElementById('root'));\n```\n\n여기까지 리액트를 사용하기 위한 되었다.  \n허나 아직은 에러와 함께 작동하지 않을 것인데, 여기서 Babel이 필요하다.\n\n\n\n## Babel 사용하기\n\nBabel env, react preset을 설치한다.\n\n```shell\n$ npm install --save-dev babel-preset-env babel-preset-react\n```\n\n`./.babelrc` 파일을 생성, 설정을 등록한다.\n```json\n{\n  \"presets\": [\"env\", \"react\"]\n}\n```\n\n여기까지 했다면 작성했던 코드가 정상적으로 출력되는 것을 볼 수 있다.\n\n\n\n## SASS(SCSS) 사용하기\n\n정상적인 설치 방법은 우선 node-sass 모듈을 설치하는 과정을 거쳐야 하나 parcel을 사용하면 더 간편하게 사용할 수 있다.\n\n현재 css 파일을 scss 확장자로 바꾸고\ncss 파일을 import 했던 부분을 scss로 바꿔주면\n\nParcel이 자동으로 node-sass를 설치하며 적용된다.\n\n\n\n## Build\n\n[공식 문서 - production](https://parceljs.org/production.html)\n\n바로 npm script를 추가해 빌드를 해보자\n```json\n\"build\": \"parcel build index.html -d build --public-url ./\"\n```\n\n`-d build`는 `./build`폴더에 빌드한다는 뜻이며,  \n\n여기서 하나 알아두면 좋은 것은 `--public-url ./` 부분이다.  \n`--public-url ./` 옵션을 주게 되면 빌드 후 아래와 같은 결과가 나온다.\n\n```html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"1a2b3c4d.css\">\nor\n<script src=\"e5f6g7h8.js\"></script>\n```\n\nGithub Page와 같은 정적 페이지 서비스를 사용할 경우에는 아래와 같이 할 수 있다.\n```shell\n$ parcel build index.html -d build --public-url https://username.github.io\n```\n\n그러면 결과가 아래와 같이 된다.\n```html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"https://username.github.io/1a2b3c4d.css\">\nor\n<script src=\"https://username.github.io/e5f6g7h8.js\"></script>\n```\n\n이렇게 빌드를 하고나면 minify된 빌드 결과물을 얻을 수 있다.\n\n\n---\n\n여기까지 정말 간단하게만 Parcel로 작은 리액트 프로젝트를 사용하기 위한 준비를 해보았다. \n\nCRA(Create-react-app)과 프로젝트를 시작하는 단계에서 비교해보면 babel 설정과 같은 부분은 Parcel이 설정해줘야하는 것이 하나 더 있다는 점이 있지만 SASS 사용 등 복잡한 Webpack config를 뒤지고 수정하는 면에서는 Parcel이 더 간편하게 사용할 수 있는 것 같다.  \n\n---\n\n- References\n  - [Parcel documents](https://parceljs.org/getting_started.html)\n","fields":{"slug":"/parcel-start/"},"frontmatter":{"title":"웹팩 대신 파셀(Parcel) 사용해보기 with React, Babel, SASS","published":true}}},{"node":{"rawMarkdownBody":"\n## Vue.JS 설치\n\n\n\n### CDN으로 설치하기\n\n```html\n<script src=\"https://unpkg.com/vue\"></script>\n```\n\n간단히 index.html 내에 위 코드를 추가하는 것만으로 vue를 간단하게 사용할 수 있다.  \n다만 CDN을 기반으로 Vue를 개발하려면 .vue 확장자를 이용하는 개발은 할 수 없어 싱글 파일 컴포넌트 개발이 불가능하고 개발에 제약이 따른다.  \n제대로 된 vue 개발을 위해서는 아래의 방법을 시도하자.\n\n### NPM으로 설치하기\n\n```shell\n# 최신 stable 버전\n$ npm install vue\n```\n\n프로젝트 내에 vue를 설치하여 사용할 수 있다. Webpack 등 각종 번들러와도 잘 작동한다.  \n허나 더 편리하게 초기 세팅을 하고 싶다면 아래의 Vue CLI를 사용하는 방법이 최선일 것이다.\n\n\n## 개발 도구 설치\n\n\n### Vue CLI\n\n```shell\n# vue-cli 설치\n$ npm install --global vue-cli\n\n# vue init <template-name> <project-name>\n# \"webpack\" 템플릿을 이용해서 새 프로젝트 생성\n$ vue init webpack my-project\n\n$ cd my-project\n# 의존성 설치\n$ npm install\n# 개발 서버 실행\n$ npm run dev\n```\n\n이렇게 하면 react의 create-react-app과 같이 webpack 환경의 프로젝트 구조가 자동 생성되며 이제 이것을 기본으로 개발을 시작하면 된다.\n\n\n### Vue DevTools\n\nReact와 유사하게 크롬 개발 도구에서 사용할 수 있는 개발툴을 지원한다.\n\n[크롬 확장 프로그램 설치](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)\n\n---\n\n## References\n- https://kr.vuejs.org\n","fields":{"slug":"/vuejs-install/"},"frontmatter":{"title":"Vue.JS 및 Vue 개발 도구 설치하기","published":true}}},{"node":{"rawMarkdownBody":"\n## Symbolic Link?\n개발을 하던 중 한 파일이 여러 곳에서 필요한 경우가 있다.  \n물론 모듈을 써서 사용하겠지만 개발 공부할 때는 종종 있는 일이다.\n\n그래서 복사 붙여놓기 보다는 나은 방법이 심볼릭 링크인 것 같아 방법을 소개한다.  \n개발 외에서도 활용하고 있는 심볼릭 링크도 소개해보겠다.\n\n```shell\n- ONE\n  - index.html\n  - style.css\n- TWO\n- THREE\n```\n<br/>\n위와 같은 폴더 구조에서 ONE 폴더에 위치한 style.css 파일이 TWO 폴더안에 필요하다고 해보자.\n```shell\n# 작업 위치를 TWO 폴더로 이동\n$ cd TWO/\n# 심볼릭 링크\n$ ln -s ../ONE/style.css style.css\n```\n<br/>\n다른 경우로 THREE 폴더에서 ONE폴더가 필요하다고 해보자.  \n그리고 THREE 폴더의 링크된 ONE폴더의 이름은 _ONE 이라 해보자.\n```shell\n# 작업 위치를 THREE 폴더로 이동\n$ cd THREE/\n# 심볼릭 링크\n$ ln -s ../ONE _ONE\n```\n이렇게 간단하게 사용할 수 있다, 어떻게 보면 복사 붙여놓기보다 간단하게 사용할 수 있다.\n\n<br/>\n이렇게 심볼링 링크된 것을 GitHub 웹페이지에서 확인해보면 어떨까?  \nTWO 폴더의 링크된 style.css 파일을 GitHub 웹페이지에서 확인해보면 아래와 같다.\n\n```\nSymbolic link |  1 lines (1 sloc) | 25 Bytes\n--------------------------------------------\n1 | ../ONE/style.css\n```\n\n---\n\n## 클라우드에 활용하기\n\n현재 NAS에 아래에서 소개할 방법으로 심볼릭 링크를 활용하고 있다, 여기서는 구글 드라이브로 예를 들어보겠다.\n\n구글 드라이브와 같은 클라우드에 폴더를 동기화할때도 요긴하게 쓰일 수 있는데,  \n컴퓨터에 설치하여 사용하는 설치형 구글 드라이브를 예로 들어보겠다.\n\nA 폴더를 구글 드라이브에서 사용하기 위해서 구글 드라이브로 복사한다면,  \n컴퓨터 저장 공간에 A폴더 용량, 그리고 구글 드라이브의 A폴더 용량.  \n이렇게 중복되어 많은 용량을 차지하게 된다.\n\n그러나 A 폴더를 심볼릭 링크로 구글 드라이브에 링크를 해놓으면 해결된다.  \n컴퓨터 내에서 구글 드라이브에 위치한 A폴더 심볼링 링크는 사실상 바로가기라고 보면 된다.\n그리고 구글 드라이브는 바로가기라고 해서 바로가기를 동기화해가는 것이 아닌 A폴더 자체를 동기화 하게 된다.  \n이렇게 하면 용량도 절약하며 링크가 되어있으므로 A폴더를 수정해도 구글 드라이브에 반영되게 된다.\n","fields":{"slug":"/mac-symbolic-link/"},"frontmatter":{"title":"MacOS, 심볼릭 링크 사용하기","published":true}}},{"node":{"rawMarkdownBody":"\n지금까지는 주로 Consolas를 기본으로 사용해왔는데 더 좋아보이는 글꼴을 찾았고 지금 상당히 만족스럽게 사용하고 있다. 바로 아래서 소개 할 'Hack'이라는 글꼴이다.\n\n## Hack \n\n- [글꼴 샘플](https://source-foundry.github.io/Hack/font-specimen.html)\n- [글꼴 써보기](https://sourcefoundry.org/hack/playground.html)\n- [글꼴 다운로드](https://sourcefoundry.org/hack/#download)\n\n이름에서도 알 수 있듯이 오로지 개발을 위해 만들어진 글꼴이다. \n\n개발자를 위한 글꼴의 조건에는 여러개가 있다, 아래는 대표적인 조건이다.\n\n햇갈릴 수 있는 글자의 구분\n: 예) i l I / 0 O / ; :\n\n고정폭일 것\n: 일반적인 글꼴은 가변폭이 많다. 대표적으로 윈도우의 '굴림'이나 '돋움'이 해당한다.  \n코딩할 땐 공백과 글자 수에 따른 일정한 넓이와 그에 따른 여러 라인을 비교할 수 있도록 고정폭 글꼴의 사용이 필요하다.\n\nHack은 이러한 조건들을 만족하는 글꼴이다.\n\n## 글꼴 설정하기\n\n### Mac\n\n'서체 관리자' 앱을 실행하여 다운받은 글꼴을 추가한다.  \n앱을 못찾겠으면 Spotlight 검색을 통해 쉽게 찾을 수 있다.\n\n### Visual Studio Code\n\n**'Code - 기본 설정'**에서 아래 설정을 추가한다.\n```json\n{\n  \"editor.fontFamily\": \"Hack\"\n}\n```\n아래와 같이 여러 글꼴을 설정할 수도 있다,  \n만약 첫번째로 설정한 글꼴가 어떠한 이유로 적용되지 않는 경우 그 다음 글꼴이 적용된다.\n```json\n{\n  \"editor.fontFamily\": \"Hack, Menlo, Monaco, 'Courier New', monospace\"\n}\n```\n","fields":{"slug":"/dev-font-vsc/"},"frontmatter":{"title":"개발자 글꼴 Hack, 그리고 VSCode 글꼴 설정하기","published":true}}},{"node":{"rawMarkdownBody":"\nHTML 태그안에 데이터 속성(**data-**)을 두어 그 데이터를 JS나 CSS에서 불러 쓸 수 있다.\n\n\n\n## HTML\n\n```html\n<tag id=\"a\" data-test-keyword=\"ABC\"></tag>\n```\n\n`data-` 뒤에 데이터 속성의 이름을 입력한다.\n\n`-`, `.`, `:`, `_` 와 영문 소문자가 입력 가능하다. (대문자는 불가능)\n\n위의 예제에서는 **test-keyword**이다.\n\n\n\n## JavaScript\n\n```javascript\nconst el = document.querySelector('#a');\n\nconsole.log(el.dataset.testKeyword); // \"ABC\"\n```\n\nJavaScript에서의 접근법으로는 `dataset` 을 이용하여 불러올 수 있다.\n\n데이터 속성 이름에서`data-`를 뺀 뒤 camelCase로 변환되어있다.\n\n따라서 위에서 지정한 `data-test-keyword`가 `testKeyword`가 되었다.\n\n\n\n## CSS\n\n```css\n#a[data-test-keyword=\"ABC\"] {\n    display: none;\n}\n```\n\nCSS에서는 HTML의 데이터 속성 이름 그대로를 사용해 접근 할 수 있다.\n\n\n\n---\n\n### References\n[https://developer.mozilla.org/ko/docs/Web/API/HTMLElement/dataset](https://developer.mozilla.org/ko/docs/Web/API/HTMLElement/dataset)\n","fields":{"slug":"/html-dataset/"},"frontmatter":{"title":"HTML 데이터 속성 사용하기 (data-, dataset)","published":true}}},{"node":{"rawMarkdownBody":"\nVisual Studio Code를 쓰기 시작하면서 데스크탑과 랩탑간 설정 동기화가 필요해 방법을 찾다가  \n확장 플러그인 **Settings Sync**를 사용하여 하는 방법을 발견했다.\n\n---\n\n## 1. 확장 플러그인 'Settings Sync' 설치\n\nhttps://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync\n\n\n## 2. GitHub account token 발급받기\n\n'Settings Sync'는 Github의 gist 토큰을 사용하여 설정 업로드, 다운로드가 이뤄진다.\n\n토큰을 발급받기 위해 Github에서 하단의 메뉴로 진입한다.\n\n**Settings > Developer settings > Personal access tokens > Generate New Token**\n\n나타나는 메뉴에서 **gist**에 체크 후 토큰을 생성한다.  \n생성 후 화면에 보이는 토큰 문자열을 이용하여 설정 업로드, 다운로드가 이뤄진다.\n\n## 3. 설정 업로드 / 다운로드\n\n단축키는 아래와 같다.\n1. Upload Key : Shift + Alt + U\n2. Download Key : Shift + Alt + D\n\n단축키를 통해 나타나는 입력칸에 토큰을 입력하면 설정 업로드, 다운로드가 이뤄지게 된다.\n한번 입력과정을 거치면 다음부터는 단축키 한번으로 업로드 다운로드가 가능하다.\n","fields":{"slug":"/vsc-settings-sync/"},"frontmatter":{"title":"Visual Studio Code 설정 기기 간 동기화하기","published":true}}},{"node":{"rawMarkdownBody":"\nWebStorm을 쓰다가 Visual Studio Code를 사용하니 React를 쓰기에 불편함이 한두가지가 아니다.\n\n제일 처음 맞은 불편함이 JSX에서 emmet 자동완성이 작동 안되는 것인데,    \n해결 방법으로 여러 방법이 있었지만 제일 간단한 방법은 아래와 같다.\n\n기본 설정에서 아래 코드를 추가해준다.\n\n```json\n{\n    \"files.associations\": {\n        \"*.js\": \"javascriptreact\"\n    }\n}\n```\n\n---\nReferences\n: [Change language to JSX in Visual Studio Code\n](https://stackoverflow.com/questions/32832264/change-language-to-jsx-in-visual-studio-code)\n","fields":{"slug":"/vsc-react-syntax/"},"frontmatter":{"title":"VSCode(Visual Studio Code)에서 React JSX 자동완성 기능 활성화하기","published":true}}},{"node":{"rawMarkdownBody":"\nMacOS 재설치 후 기본적인 설정을 하면서 **간단히** 정리해본 MySQL 설치 과정\n\n\n## MySQL 설치\n```\n$ brew install mysql\n```\n\nbrew 명령어를 위한 HomeBrew 패키지 관리자 미설치시 아래 명령어를 통해 설치 필요  \n`$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"`\n\n\n## MySQL 설정\n아래 명령어로 mysql을 시작합니다.\n```\n$ mysql.server start\n```\n\n아래 명령어로 기본 설정을 시작합니다.\n```\n$ mysql_secure_installation\n```\n이제 여러 질문들이 출력됩니다.  \n출력에 대한 답은 본인이 한 방법으로만 간단하게 기술하겠습니다.\n\n우선 아래의 과정에 앞서 정리해보자면 아래와 같습니다.\n1. 비밀번호 복잡도 검사 과정 (n)\n2. 비밀번호 입력 & 확인\n3. 익명 사용자 삭제 (y)\n4. 원격 접속 허용 (n)\n5. test DB 삭제 (n)\n6. 수정할 것이 있는가? (y or n)\n\n아래는 위에 나타낸 과정의 자세한 내용입니다.\n\n```\nSecuring the MySQL server deployment.\n\nConnecting to MySQL using a blank password.\n\nVALIDATE PASSWORD PLUGIN can be used to test passwords\nand improve security. It checks the strength of password\nand allows the users to set only those passwords which are\nsecure enough. Would you like to setup VALIDATE PASSWORD plugin?\n\nPress y|Y for Yes, any other key for No:\n```\n위의 과정은 복잡한 비밀번호 설정을 위한 과정을 거치겠냐고 묻는 과정이며,  \n**No**로 스킵하였습니다.\n\n```\nPlease set the password for root here.\n\nNew password:\n\nRe-enter new password:\n```\n위의 과정은 루트 비밀번호를 입력하는 과정입니다.  \n비밀번호와 비밀번호 확인란을 입력하게 됩니다.\n\n```\nBy default, a MySQL installation has an anonymous user,\nallowing anyone to log into MySQL without having to have\na user account created for them. This is intended only for\ntesting, and to make the installation go a bit smoother.\nYou should remove them before moving into a production\nenvironment.\n\nRemove anonymous users? (Press y|Y for Yes, any other key for No) : y\n```\n익명 사용자를 삭제할 것인지 묻습니다.  \n**y**를 입력하였습니다.\n\n```\nNormally, root should only be allowed to connect from\n'localhost'. This ensures that someone cannot guess at\nthe root password from the network.\n\nDisallow root login remotely? (Press y|Y for Yes, any other key for No) : y\n```\n원격 접속을 허용할 것인지 묻습니다,  \n로컬에서만 개발 예정이기에 **y**를 입력했습니다.\n\n```\nBy default, MySQL comes with a database named 'test' that\nanyone can access. This is also intended only for testing,\nand should be removed before moving into a production\nenvironment.\n\nRemove test database and access to it? (Press y|Y for Yes, any other key for No) :\n```\ntest 데이터베이스 삭제를 묻고 있습니다.  \n**No**를 입력하였습니다.\n\n```\nReload privilege tables now? (Press y|Y for Yes, any other key for No) :\n```\n수정할 것이 있다면 위의 설정 과정을 다시 거칠 수 있습니다.  \n**No**를 입력하였습니다.\n\n```\nAll done!\n```\n위의 메세지와 함께 설정이 종료됩니다.\n\n## MySQL 사용\n```\n$ mysql -u root -p\n```\n위 명령어 입력 후 루트 비밀번호를 입력하여 mysql을 사용할 수 있게 됩니다.\n","fields":{"slug":"/mac-install-mysql/"},"frontmatter":{"title":"간단하게 MySQL 설치하기 (Mac, HomeBrew)","published":true}}},{"node":{"rawMarkdownBody":"\nMacOS 재설치 후 기본적인 설정을 하면서 **간단히** 정리해본 Node.js, npm, yarn 설치 과정\n\n## Node, NPM 설치\nNode를 설치하기에 가장 간단하고 좋은 방법이라 생각하는 HomeBrew를 통한 설치를 해보겠습니다.  \n좋은 방법이라는 이유는 업데이트, 제거가 다른 설치 방법에 비해 비교적 쉽기 때문입니다.\n\n아래 명령어를 통해 설치를 진행합니다.\n```\n$ brew install node\n```\n\nbrew 명령어를 위한 HomeBrew 패키지 관리자 미설치시 아래 명령어를 통해 설치 필요  \n(brew가 설치되어 명령어가 정상작동했다면 아래 명령어는 불필요합니다.)\n```\n$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n설치 확인 & 버전 확인\n```\n$ node -v\n$ npm -v\n```\n\n## yarn 설치\nyarn 설치시 위에서 Node는 설치하였으니 node를 빼고 설치하도록 합니다.\n```\n$ brew install yarn --without-node\n```\n\n설치 확인 & 버전 확인\n```\n$ yarn -v\n```\n## 업데이트 & 언인스톨 방법\n\n차후 업데이트 또는 언인스톨이 필요할 때 아래와 같은 방법으로 가능합니다.\n\n### 업데이트\n```\n  우선 HomeBrew를 최신버전으로 업데이트 합니다.\n$ brew update\n\n  원하는 업데이트를 수행합니다.\n$ brew upgrade node\n$ brew upgrade yarn\n```\n\n### 언인스톨\n```\n$ brew uninstall node\n$ brew uninstall yarn\n```\n","fields":{"slug":"/install-node-yarn/"},"frontmatter":{"title":"간단하게 Node.js, npm, yarn 설치하기","published":true}}},{"node":{"rawMarkdownBody":"\nMacOS 재설치 후 기본적인 설정을 하면서 **간단히** 정리해본 Mac 터미널 세팅 과정\n\n## zsh, Oh My Zsh\n우선 기본 Terminal에서 zsh와 Oh My Zsh를 설치합니다. \n\n### zsh 최신 버전 설치\n1. zsh 현재 버전 확인\n  ```\n$ zsh --version\n  ```\n2. zsh 최신 버전 설치\n  ```\n$ brew install zsh\n  ```\n  ```\n  # brew 명령어를 위한 HomeBrew 패키지 관리자 미설치시 아래 명령어를 통해 설치 필요\n  # 위 명령어가 이상없이 작동한다면 아래 명령어는 불필요합니다.\n  $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n  ```\n3. Terminal 재실행 후 zsh 현재 버전 확인\n  ```\n$ zsh --version\n  ```\n\n\n### Oh My Zsh 설치\n```\n$ sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n<br/>\n\n\\+ 다른 블로그들에는 터미널의 기본 쉘 실행을 zsh로 바꿔야 한다는 말이 있었으나  \n실제 해보니 그런 과정 없이도 위와 같은 설치 과정을 지나니 기본 실행이 zsh로 바뀌어있었다.\n<br/>\n\n### iTerm 설치\n이제 기본 터미널을 대체해서 사용할 iTerm을 설치합니다.\n\n[다운로드 페이지](https://www.iterm2.com/downloads.html){: .btn .btn--info}\n\n\\+ 원래는 테마 변경을 해서 썼지만 이번에는 기본 테마에 색상만 가독성 좋은 색상 스키마로 변경하여 사용해 볼 예정이다.\n","fields":{"slug":"/mac-terminal/"},"frontmatter":{"title":"Mac Terminal 설정 (OhMyZsh, iTerm)","published":true}}},{"node":{"rawMarkdownBody":"\n사용중인 플러그인을 정리해놓았다.  \n~~취소선은 설치했으나 비활성화 중인 것~~이다.\n\n## List\n\nLast Update : 2018-10-15\n\n---\n\n### - Active File In StatusBar\n\n현재 작업중인 파일의 전체 경로를 아래 상태표시줄에 표시해준다\n\n### - Auto Rename Tag\n\n짝이 되는 태그(\\<a>, \\</a>)를 자동으로 같이 수정한다.\n\n### - Angular Language Service\n\n앵귤러 템플릿 서포트\n\n### - ~~Auto Close Tag~~\n\n태그를 자동으로 닫아준다.\n\n### - Blank line at end of file\n\n저장할때 파일의 마지막에 빈줄이 없다면 자동으로 추가해준다.\n\n### - Debugger for Chrome\n\n크롬 디버깅 환경 사용을 위한 확장.\n\n### - ESlint\n\nECMAScript Linter\n\n### - Git History\n\n깃 히스토리를 보기 좋게 보여준다.\n\n### - gitignore\n\n.gitignore 를 사용할 환경에 맞춰 만들어주는 확장.\n\n### - highlight-matching-tag\n\ntag 를 클릭하면 해당 태그의 시작과 끝 부분을 강조해준다.\n\n### - indent rainbow\n\n들여쓰기 단계에 따른 들여쓰기 공간의 색상을 다르게 표시해준다.\n\n### - IntelliSense for CSS class names in HTML\n\n자동 CSS 클래스명 완성 기능\n\n### - Markdown Navigation\n\n헤딩에 따라 목차를 보여준다.\n\n### - npm\n\nnpm 보조 확장.\n\n### - npn Intellisense\n\nnode module 을 import 시에 자동 완성 기능\n\n### - Path Intellisense\n\n파일 경로를 자동 완성해주는 기능\n\n### - PostCSS Sorting\n\nCSS 속성을 알파벳순으로 정렬하는 등, CSS 정렬에 사용한다.\n\n### - Prettier\n\n위의 Beautify 가 react 에서 잘 작동하지 않아 쓰게 된 확장.\n\n### - Rainbow Brackets\n\n브라켓의 색상을 단계별로 다르게 표시해준다.\n\n### - React Native Tools\n\n리액트 네이티브 서포트\n\n### - Reactjs code snippets\n\n리액트 코드 자동완성 스니펫 추가를 위한 확장.\n\n### - Sass\n\nSass 서포트\n\n### - Setting Sync\n\nVSCode 설정 동기화 도구\n\n### - TODO Highlight\n\nTODO: FIXME: 구문 하이라이트.\n\n### - TSLint\n\nTypeScript Linter\n\n### - Vetur\n\nVue 서포트\n\n---\n\n## Theme\n\n### - Color\n\n- ~~FlatUI~~\n- ~~1337~~\n- ~~Material Theme Kit~~\n- dracular official\n\n### - Icon\n\n- Marterial Icon Theme\n\n---\n\n**추가로 VSCode 사용에 도움이 될 만한 자료들**  \n\\- [VS Code Tips and Tricks](https://github.com/Microsoft/vscode-tips-and-tricks?wt.mc_id=DX_881390#extension-recommendations)\n","fields":{"slug":"/vsc-plugin-list/"},"frontmatter":{"title":"사용중인 VSCode(Visual Studio Code) 확장 플러그인 목록","published":true}}},{"node":{"rawMarkdownBody":"\n기존 Jekyll을 이용한 블로그는 현재(2018.09) Gatsby를 이용한 블로그로 개편되었습니다.  \nJekyll의 minimal-mistakes테마를 이용한 블로그를 만들고 싶다면 아래 게시물은 아직 유효합니다.\n\n---\n\njekyll 블로그를 시작하기 위한 준비를 저번 포스트에서 끝냈다.  \n이제 테마를 적용하고자 여러 테마를 찾던중 정말 괜찮은 테마를 발견했고 그것을 적용하는 과정을 포스팅하려고 한다.\n\n테마의 이름은 'Minimal Mistakes'로 github star와 fork를 보아 인기있는 테마인듯 싶다.  \n심플한 디자인과 가독성이 맘에 들었고 무엇보다 문서가 너무나 잘 정리되있다는 점에 있어서 선택하게 되었다.\n\n### Minimal Mistakes\n- [Official & Demo Page](https://mmistakes.github.io/minimal-mistakes)\n- [Github](https://github.com/mmistakes/minimal-mistakes)\n\n\n## 테마 적용하기\n우선 기존 포스트에서 jekyll 설치를 다뤘는데, 그로인해 기본 테마로 적용이 되어있는 상태이다.  \n여기서 테마를 적용하는 방법으로는 여러가지가 있다. \n\n가장 쉬운방법은 테마의 github에서 fork를 하고 리포지토리 이름을 `username.github.io`로 바꾸는 방법이다.\n\n만약 기존에 해둔 리포지토리를 파괴하지 않는 선에서 테마를 적용하고 싶다면 테마를 다운받아 기존 리포지토리 폴더에 덮어쓰기 하는 방법도 있다.\n\n여기서는 깔끔하게 비어있는 리포지토리에서 테마를 적용하는 방법을 기술하겠다.\n\n만약 지금 보고있는 블로그가 맘에 들고 아래 방법보다 더 쉽게 테마 적용하고 싶다면 지금 이 블로그의 GitHub 리포지토리를 Fork해 사용할 수 있도록 방법을 만들어놨으니 포스팅을 참고하면 된다.  \n[Jekyll 블로그 테마 ‘쉽게’ 적용하기 (minimal-mistakes)](https://junhobaik.github.io/jekyll-apply-theme-simple)\n{: .notice--warning}\n\n### 테마 다운받아 적용하기\n\n테마를 다운받으려면 보통 리포지토리를 clone하거나 zip파일로 다운받는 방법이 보통이다.  \n아니면 jekyll theme 페이지에서 다운받는 방법이 있다.  \n\nminimal mistakes 테마를 다운받으려 github 리포지토리를 zip으로 다운받아 시도하였다.  \n허나 사이드바 표시등 자잘한 문제가 보여 정식 릴리즈된 파일을 찾아 다운받았다.\n\n[https://github.com/mmistakes/minimal-mistakes/releases](https://github.com/mmistakes/minimal-mistakes/releases)\n\n다운받은 폴더의 내용을 프로젝트 폴더(username.github.io)에 옮긴다.  \n이 과정에서 아래를 참조해 불필요한 파일을 삭제하도록 한다.\n\n### 불필요한 파일 삭제\n불필요한 파일은 아래와 같다.  \n- .editorconfig\n- .gitattributes\n- .github\n- /docs\n- /test\n- CHANGELOG.md\n- minimal-mistakes-jekyll.gemspec\n- README.md\n- screenshot-layouts.png\n- screenshot.png\n\n### _posts, _draft 폴더 생성\n그리고 _posts와 _draft 폴더가 없다면 생성하도록 한다. (최상위 경로)\n- _drafts : 포스트 초안이 담기는 곳이다. 배포되지 않고 테스트 환경에서 보기가 가능하다.\n- _posts : 배포될 포스트들이 담기는 곳.\n\n### .gitignore 생성\n\n다음으로 최상위 경로에 .gitignore 파일이 없다면 생성하고 있다면 아래 내용을 보충하자.  \n[Jeklly gitignore list](https://gist.github.com/bradonomics/cf5984b6799da7fdfafd)\n\n### Gemfile 수정\nGemfile을 아래 내용으로 수정한다.\n\n```yml\nsource \"https://rubygems.org\"\n\ngem \"jekyll\", \"~> 3.5\"\ngem \"minimal-mistakes-jekyll\"\n```\n\n아래 명령어를 수행한다.\n```\n$ bundle\n```\n\n### 테스트, 배포\n이제 기본적으로 테마 적용이 완료되었다. 다음으로 개인에 맞춰 커스터마이징 하면 된다.  \n그 전에 한번 테스트와 배포를 해보자.\n\n```\njekyll serve\n```\n위 명령어로 `localhost:4000`에서 로컬로 띄워볼 수 있다.\n\n이 명령어 뒤에 붙는 옵션으로 유용한 것은\n- `--draft` 초안을 같이 표시한다.\n- `--livereload` 수정마다 새로고침된다.\n\n중요한 것은 `_config.yml` 파일을 수정하는 것은 반영되지 않아 다시 명령어를 수행해야 반영 된다.\n\n다음으로 git comit, push 를 통해 자신의 github page에 올린다.\n\n예)\n```\n$ git add .\n$ git commit -m 'Apply theme, minimal mistakes'\n$ git push\n```\n\n`username.github.io`에 접속해 제대로 반영 되었는지 확인한다.\n\n## 테마 설정하기\n이제 개인에 맞춰 커스터마이징 할 차례이다.  \n구체적인 것은 생략하고 기본적으로 수정이 필요한 내용들만 다루겠다.  \n\n`_config.yml`을 수정하자.\n\n설정을 수정할때는 `jekyll serve`가 실시간 반영되지 않으니 다시 명령어를 수행해야하는 점을 유의하자.\n\n### 테마 스킨\n```yml\nminimal_mistakes_skin : \"defalut\"\n```\n테마의 전체적인 색상 스킨을 정할 수 있다.   \n스킨은 아래 링크에서 확인 할 수 있다.  \n[Skin list](https://mmistakes.github.io/minimal-mistakes/docs/configuration/#skin)\n\n### Site Settings\n\n```yml\nlocale                   : \"ko\" # 타깃 국가 설정\ntitle                    : \"블로그 제목\" # 블로그 좌측상단의 제목\nname                     : \"블로그 이름\"\ndescription              : \"블로그 설명\"\nurl                      : \"https://username.github.io\" # 블로그 주소\nrepository               : \"username/username.github.io\" # 블로그 github 리포지토리\nsearch                   : true # 사이트 우측 상단 검색 활성화\nsearch_full_content      : # 제목이 아닌 내용까지도 검색할 것인지에 대한 설정 기본 false\n```\n\n### Site Author\n사이트 운영자에 대한 정보를 적는다.  \n사이드바에 표시되는 사항들이다.\n\n```yml\nauthor:\n  name             : \"이름\"\n  avatar           : \"/assets/images/bio-photo.jpg\" # 프로필 사진\n  bio              : \"이름 아래 나타날 자신의 설명\"\n  location         : \"Seoul,Korea\"\n  email            : \"a@b.c\"\n  uri              : # 웹사이트, 보통 지금 블로그 말고 링크해두고 싶은 사이트를 적는다.\n  # 이 아래 쇼셜 리스트에 해당되는 것에 아이디를 적는다\n  github : \"username\" # 주소 전체를 적는 것이 아닌 자신의 정보만 적는다.\n```\n\n### Defaults\n```yml\n# Defaults\ndefaults:\n  # _posts\n  - scope:\n      path: \"\"\n      type: posts\n    values:\n      layout: single\n      author_profile: true\n      read_time: false # 해당 포스트를 읽은 시간이 표시되는데 기본값은 true이다.\n      comments: # true\n      share: true # 포스트 공유 기능을 활성화 할 것인지 정한다. 기본값은 true이다.\n      related: true\n```\n### 댓글 설정\ndisqus를 적용해 보기 위해 우선 disqus에서 사이트를 하나 추가하고 `short-name`을 알아둔다\n\n아래 코드를 보고 `_config.yml`의 설정을 수정한다\n\n```yml\ncomments:\n  provider               : \"disqus\"\n  disqus:\n    shortname            : dev-hundred-blog # Short-name\n\ndefaults:\n  # _posts\n  - scope:\n      path: \"\"\n      type: posts\n    values:\n      layout: single\n      author_profile: true\n      read_time: false\n      comments: true # 댓글 활성화\n      share: true\n      related: true\n```\n\n\n## Navigation 설정\n헤더 부분에 표시될 네비게이션 메뉴 설정을 하겠다.  \n주로 많이 사용하는 메뉴들로 기본 설정을 해보겠다.  \n- Archive\n- Tag\n- Category\n\n기본적으로 `_data/navigation.yml`에서 네비게이션 설정을 할 수 있다.  \n예로 Archive라는 메뉴 하나가 네비게이션에 있다고 하면 아래와 같다.\n\n```yml\nmain:\n  - title: \"Archive\"\n    url: /year-archive/\n```\n\nurl은 `_pages`폴더안에 있는 페이지의 permalink와 연결된다.\n\n`_pages/year-archive.html`\n```yml\n---\nlayout: archive\npermalink: /year-archive/\ntitle: \"Posts by Year\"\nauthor_profile: true\n---\n# ... Code Here ...\n```\n\n이제 실제로 적용을 해보도록 하자.\n기본적인 양식은 [minimal mistakes의 github의 예제](https://github.com/mmistakes/minimal-mistakes/tree/master/docs) 양식을 가져왔다.\n\n`_data/navigation.yml`\n```yml\nmain:\n  - title: \"Archive\"\n    url: /year-archive/\n  - title: \"tag\"\n    url: /tags/\n  - title: \"Category\"\n    url: /categories/\n```\n\n`_pages/year-archive.html`\n\n```liquid\n---\nlayout: archive\npermalink: /year-archive/\ntitle: \"Posts by Year\"\nauthor_profile: true\n---\n{% assign postsByYear = site.posts | group_by_exp:\"post\", \"post.date | date: '%Y'\"  %}\n{% for year in postsByYear %}\n  <h2 id=\"{{ year.name | slugify }}\" class=\"archive__subtitle\">{{ year.name }}</h2>\n  {% for post in year.items %}\n    {% include archive-single.html %}\n  {% endfor %}\n{% endfor %}\n```\n\n\n`_pages/tag-archive.html`  \n\n태그 부분은 기본 양식에서 살짝 수정했다.\n\n```liquid\n---\nlayout: archive\npermalink: /tags/\ntitle: \"Posts by Tag\"\nauthor_profile: true\n---\n{% include group-by-array collection=site.posts field=\"tags\" %}\n<ul>\n  {% for tag in site.tags %}\n    <span>\n      <a href=\"#{{ tag | first }}\">\n        {{ tag | first }}\n      </a> &nbsp;&nbsp;&nbsp;\n    </span>\n  {% endfor %}\n</ul>\n<br/>\n<br/>\n{% for tag in group_names %}\n  {% assign posts = group_items[forloop.index0] %}\n  <h2 id=\"{{ tag | slugify }}\" class=\"archive__subtitle\">{{ tag }}</h2>\n  {% for post in posts %}\n    {% include archive-single.html %}\n  {% endfor %}\n{% endfor %}\n```\n\n`_pages/category-archive.html`\n\n```liquid\n---\nlayout: archive\npermalink: /categories/\ntitle: \"Posts by Category\"\nauthor_profile: true\n---\n{% include group-by-array collection=site.posts field=\"categories\" %}\n{% for category in group_names %}\n  {% assign posts = group_items[forloop.index0] %}\n  <h2 id=\"{{ category | slugify }}\" class=\"archive__subtitle\">{{ category }}</h2>\n  {% for post in posts %}\n    {% include archive-single.html %}\n  {% endfor %}\n{% endfor %}\n```\n\n---\n\n이제 어느정도 블로그를 운영할 수 있게 된 것 같다.  \n허나 아직 세부적으로 코드 수정을 통해 커스터마이징 할 것들이 보인다.  \n\n이번 포스팅은 여기까지 하고 차후에 SEO 관련 포스팅을 할 생각이다.\n\n---\n\n### References\n- [Minimal Mistakes Quick-Start Guide](https://mmistakes.github.io/minimal-mistakes/docs/quick-start-guide/)\n","fields":{"slug":"/jekyll-apply-theme/"},"frontmatter":{"title":"Jekyll 블로그 테마 적용하기 (minimal-mistakes)","published":true}}},{"node":{"rawMarkdownBody":"\n참고: 지금 계신 블로그는 기존 Jekyll을 이용한 블로그에서 현재(2018.09) Gatsby를 이용한 블로그로 개편되었습니다.  \n\n---\n\n원래는 Hexo 블로그 프레임워크를 사용하여 블로그를 시작하려했었다.  \nHexo를 사용하려던 이유는 Node.js 기반의 코드로 아는 분야이므로 코드 수정에 있어 이점이 있을거라고 생각한 이유가 컸다. 하지만 여러 테마를 둘러보고 커스터마이징 함에 있어 중국어라는 난관에 부딪쳤다. 제작사가 대만쪽이며 테마 제작자들도 대부분이 중국어권이라 문서를 보는데 큰 어려움이 있었다.\n\n차선책으로 jekyll 블로그 프레임워크를 사용해보기로 했다.  \n기본적으로 GitHub에서 지원하기 때문에 신뢰성이 높았고 Hexo보다는 대중적이라 생각되어 선택하였다.\n\n아래는 jekyll 블로그를 시작하기위해 고군분투(?)한 내용이다.\n\n## Ruby 설정\n\nRuby 설정 전에 `$ sudo gem install jekyll bundler` 명령어로 jekyll 설치가 정상적으로 진행되었다면 Ruby 설정은 넘어가도 된다\n{: .notice--info}\n\n우선 사용해보지 않은 Ruby를 사용하기 위해 설정에 들어갔다.\n\nMacOS에서는 기본적으로 Ruby를 지원하지만, 그냥 사용하여 Jeklly를 설치하려했더니 권한 문제등 에러가 많아 Ruby 버전 매니저인 RVM을 통해 새로운 Ruby 설치 및 설정을 해보았다.\n\n해야할 과정들을 요약하면 아래와 같다  \n1. RVM 설치   \n`$ \\curl -sSL https://get.rvm.io | bash -s stable` \n2. Ruby 설치  \n`$ rvm install 2.5.0` \n3. 설치된 버전 기본 사용 설정  \n`$ rvm --default use 2.5.0`\n\n하지만 이 과정 중 생각보다 오류가 많이 발생했다.  \n이 아래는 오류를 겪는 과정과 해결 과정이다.\n\n### RVM, Ruby 설치\n\n```\n$ \\curl -sSL https://get.rvm.io | bash -s stable\n```\n\n위 명령어를 통해 RVM을 설치하였다.  \n다음으로는 rvm을 통해 버전 2.5.0의 Ruby 설치를 시도하였다.\n\n```\n$ rvm install 2.5.0\n```\n\n허나 `command not found: rvm` 오류 발생, rvm이 설치가 잘못된 것일까\n구글링을 통해 해결 방법을 알아내었고 아래와 같다.\n\n```\n$ source ~/.rvm/scripts/rvm\n$ type rvm | head -n 1\n\"rvm ~ function ~\" 이와 비슷한 출력시 완료\n```\n\n이제 다시 다시 루비 설치를 시도하였다.\n\n```\n$ rvm install 2.5.0\n```\n\n그러나 아래와 같은 오류 발생, 일단 위의 오류는 해결한 것이고 다른 오류가 발생한 것이다.\n\n```\nError running 'requirements_osx_brew_libs_install autoconf automake libtool pkg-config coreutils libksba openssl@1.1',\nplease read /Users/junhobaik/.rvm/log/1515943113_ruby-2.5.0/package_install_autoconf_automake_libtool_pkg-config_coreutils_libksba_openssl@1.1.log\nRequirements installation failed with status: 1.\n```\n해결을 위해 아래 명령어 입력\n\n```\n$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n위 명령어의 설치 작업으로 다소 시간이 소요되었고 다시 루비 설치를 시도하였다.\n\n```\n$ rvm install 2.5.0\n```\n\n드디어 설치 성공, 그리고 아래 명령어를 통해 설치된 버전을 기본 사용 설정을 해둔다.\n\n```\n$ rvm --default use 2.5.0\n```\n\n<br/>\n\n## Jekyll 설치\n\n`$ sudo gem install jekyll bundler`\n\n위의 명령어를 통해 `jekyll`와 `bundler`를 설치한다.\n\n이로써 설치 작업은 끝났다.\n\n\n## Github Page와 연동\n\n우선 Github Page를 사용하여 배포하기 위해 미리 `username.github.io` 리포지토리를 준비해두었고, 빈 리포지토리를 로컬에 git clone 해두었다.\n\n```\n$ jekyll new username.github.io\n```\n\n위 명령어를 통해 jekyll init이 되었고 이제 블로그를 시작할 수 있는 상태가 되었다.\n\n또한 아래 명령어를 통해 로컬에서 테스트가 가능하다.\n\n```\njekyll serve\n```\n\n다음 포스트에서는 테마 적용을 해보려 한다.\n","fields":{"slug":"/start-jekyll-blog/"},"frontmatter":{"title":"Jekyll 블로그 시작하기 (MacOS, GitHub Page)","published":true}}},{"node":{"rawMarkdownBody":"\n자바스크립트에서 함수선언문과 함수표현식의 차이점을 인식해두는 것은 중요한 점이다.\n큰 차이점이라 하면 호이스팅(Hoisting)이라고 할 수 있다.\n\n우선 함수선언문과 같은 경우를 살펴보자.\n\n```javascript\nfunctionDeclaration();\nfunction functionDeclaration(){\n  return 'functionDeclaration';\n}\n```\n\n```javascript\n'functionDeclaration'\n```\n\n함수 선언문의 경우에는 호이스팅에 의해 함수 전체가 호이스팅의 대상이 된다.\n따라서 작성한 코드에서 함수 선언문 보다 위에 함수 호출이 있더라도 정상적으로 호출이 된다.\n\n다음으로 함수표현식의 경우를 살펴보자\n\n```javascript\nunnamedFunctionExpression();\nvar unnamedFunctionExpression = function(){\n  return 'unnamedFunctionExpression';\n}\n```\n\n```\nUncaught TypeError: unnamedFunctionExpression is not a function\n```\n\n결과는 unnamedFunctionExpression 변수가 함수가 아니라는 오류가 뜨게 된다.\n변수 선언 자체는 호이스팅되었지만 할당은 호이스팅의 대상이 아니므로 할당된 값이 없는 변수를 함수라 여기고 함수 호출을 한 샘이니 이러한 오류가 발생한 것이다.\n\n즉, 함수 선언문과 함수 표현식의 차이는 호이스팅 여부를 가름짓는 **할당**에 있다고 할 수 있다.\n\n함수선언문을 사용해서 나타날 수 있는 문제점을 아래 코드에 나타냈다.\n\n```javascript\nfunction a(){\n  return 'a';\n}\na();\nfunction a(){\n  return 'A';\n}\na();\n```\n\n위의 코드는 a A 를 원하지만 A A가 나오게 된 문제가 생긴 코드 라인이 방대한 프로젝트의 경우 위와같은 커뮤니케이션 오류에 따라 원하는 함수의 결과를 얻지 못할 수 있다.\n\n이러한 점들을 종합해 함수선언문의 사용보다는 함수표현식의 사용이 권장된다.  \n유명한 더글라스 크락포드 그리고 Airbnb의 Code Convension에서도 함수표현식을 권장하고 있다.\n\n## Reference\n\n- [KENDRICK'S BLOG](http://blog.sonim1.com/142)\n- [CAPTAIN PANGYO](https://joshua1988.github.io/web-development/javascript/function-expressions-vs-declarations/#%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%EC%8B%9D---function-declarations)\n","fields":{"slug":"/js-functions/"},"frontmatter":{"title":"Javascript 함수선언문과 함수표현식","published":true}}},{"node":{"rawMarkdownBody":"\nHoist는 \"끌어올리다\"라는 뜻을 가지고 있다.  \n자바스크립트 엔진은 코드를 실행하기 전에 코드 전체를 살펴본다.  \n이 과정에서 선언된 내용이 있는지 '선언'을 살펴본다.  \n그리고 그 '선언'된 내용들을 모두 호이스팅. 즉, 끌어올리게 된다.  \n\n아래 코드를 보자.\n\n\n```javascript\nconsole.log(a());\nconsole.log(b);\nconsole.log(c());\nfunction a() {\n  return 'a';\n}\nvar b = 'b';\nvar c = function(){\n  return 'c';\n}\n```\n\n일반적인 생각으로 코드가 라인 순서대로 실행된다면, \n1번 라인에서부터 함수 a가 선언되기 전이므로 a가 없어 오류가 발생해야한다.\n하지만 위에서 설명한 호이스팅에 따라서 결론적으로 실행되는 코드는 아래와 같게 된다.\n\n```javascript\nfunction a() {\n  return 'a';\n}\nvar b;\nvar c;\nconsole.log(a());\nconsole.log(b);\nconsole.log(c());\nb = 'b';\nc = function(){\n  return 'c';\n}\n```\n\n**함수 선언문 a는 통째로 끌어올려졌다.**\n기본 값이 담긴 변수 b와 함수 표현식 c는 선언만 끌어올려졌다.\n할당은 호이스팅의 해당 사항이 아니다.\nb와 c는 선언과 할당이 동시에 이루어진 것으로 분리되어 선언만 호이스팅 된 것이다.\n\n따라서 위의 코드에서는 에러가 하나 발생하게 된다.\n\n```javascript\na\nundefined\nUncaught TypeError: c is not a function\n```\n\n`console.log(a())`는 정상적으로 출력되어 'a'가 출력되었고,\n`console.log(b)`는 `var b`의 선언만이 호이스팅 되었으므로 undefined가 출력,\n`console.log(c())`는 `var c`의 선언만이 있고 함수 호출을 하였으므로 함수가 아니라는 오류가 발생하게 된다.","fields":{"slug":"/js-hoisting/"},"frontmatter":{"title":"자바스크립트 호이스팅(Hoisting)","published":true}}},{"node":{"rawMarkdownBody":"\n`git log --oneline --graph` 처럼 명령어를 입력하면 Log를 보기 좋게 출력할 수 있는데,  \n매번 이 명령어를 치기도 곤혹이다. \n\nLinux의 alias를 이용하여 특정 명령어를 별도의 키워드로 지정하여 간단하게 사용할 수 있는다.\n\n```\n$ git config --global alias.[키워드] [명령어]\n```\n\n\n\n예로 `git log --oneline --graph`를 `git logs`로 간단히 사용하려면 아래와 같은 명령어를 사용한다.\n\n```\n$ git config --global alias.logs 'log --oneline --graph'\n```\n\n그 결과 아래와 같이 되었다.\n\n```\n$ git logs\n*   73a81d6 Merge branch 'dev'\n|\\\n| * 6f75a02 Add memo features\n| * b4de8c5 Modify bookmark localstorage name\n| * 7fa5424 Modify styles\n| * 86a5634 Add memo.js, add mvc layout\n| * 3688670 Add memo script\n| * 76e1478 Modify namespace name\n| * bd6dbdd Add bookmark title\n| * 4fbe5fb Add memo layout\n* | 78addaa Update README.md\n|/\n* 328f641 Fix bookmark add bug\n*   eb32dbc Merge branch 'dev'\n|\\\n| * 84b0d77 Modify bookmark modal style\n| * 4fc5a5c Modify bookmark bug fix\n| * 5ac2c33 Modify bookmark modal message\n| * 0a08125 Modify bookmark modal style\n| * 9d88539 Modify bookmark.js, Remove Unused property\n| * 34a6dd1 Refactoring bookmark.js\n| * 57cdfc5 Add .gitignore\n| * 1d1145b Modify bookmark, add drag sorting feature\n| * 2b13a6a Add jQuery-ui\n| * ebc5f98 Modify bookmark.js\n| * a58d2ff Modift bookmark, add modify function\n| * f0c1224 Modify Styles\n| * 4cf5a2a Modify index.html, cdn -> local\n| * c7d3110 Add Bootstrap local file\n```\n","fields":{"slug":"/git-alias/"},"frontmatter":{"title":"Git, Alias(별칭)를 이용하여 편리하게 명령어 사용하기","published":true}}},{"node":{"rawMarkdownBody":"\n## 환경\n\n- Create-react-app (CRA)\n- SCSS 로 적용\n\n\n\n\n## 적용법\n\n### react 설정 eject & sass 패키지 설치\n\n1. `$ npm run eject` 를 실행한다.\n   해당 명령어는 `node_modules/react-scripts`에 위치하던 환경설정을 프로젝트 루트 경로로 이동시켜 상세한 환경설정이 가능하도록 한다.\n2. `npm install --save node-sass sass-loader`  두개의 패키지를 설치한다.\n   - node-sass : sass 코드를 css 코드로 변환\n   - sass-loader : webpack에서 sass 파일을 읽는 역할.\n\n\n### 코드 수정\n\n#### `config/webpack.config.dev.js` \n\nfile-loader 키워드를 찾아 아래 코드에서 exclude 배열에 ` /\\.scss$/`를 추가해준다.\n\n```javascript\n{\n  // exclude: [/\\.js$/, /\\.html$/, /\\.json$/] \n  exclude: [/\\.js$/, /\\.html$/, /\\.json$/, /\\.scss$/],\n    loader: require.resolve('file-loader'),\n      options: {\n        name: 'static/media/[name].[hash:8].[ext]',\n      },\n},\n```\n\n`test: /\\.css$/` 키워드를 찾아 아래 코드를 수정한다.\n\n- `test: /\\.css$/`를 `test: /\\.scss$/`로 수정한다.\n- postcss-loader 로더 아래 sass-loader 로더 코드를 추가한다\n\n\n```javascript\nmodule : {\n  //...\n    {\n      // test: /\\.css$/,\n      test: /\\.scss$/,\n        use: [\n          require.resolve('style-loader'),\n          {\n            loader: require.resolve('css-loader'),\n            options: {\n              importLoaders: 1,\n            },\n          },\n          {\n            loader: require.resolve('postcss-loader'),\n            options: {\n              ident: 'postcss',\n              plugins: () => [\n                require('postcss-flexbugs-fixes'),\n                autoprefixer({\n                  browsers: [\n                    '>1%',\n                    'last 4 versions',\n                    'Firefox ESR',\n                    'not ie < 9',\n                  ],\n                  flexbox: 'no-2009',\n                }),\n              ],\n            },\n          },\n          // 아래 4줄 코드 추가\n          {\n            loader: require.resolve('sass-loader'),\n            options: {}\n          }\n          // \n        ],\n    },\n    /...\n}\n```\n\n\n\n#### `config/webpack.config.prod.js` \n\n위 dev 설정 파일과 비슷하게 수정한다.\n\n- file-loader 키워드를 찾아 아래 코드에서 exclude 배열에 ` /\\.scss$/`를 추가해준다.\n- `test: /\\.css$/` 키워드를 찾아 코드를 수정한다.\n  - `test: /\\.css$/`를 `test: /\\.scss$/`로 수정한다.\n  - postcss-loader 로더 아래 sass-loader 로더 코드를 추가한다\n\n\n\n## 사용\n\n기존의 css 파일을 scss로 확장자 변경하여 사용할 수 있다.\n\n또한 설정 변경 전 `npm start`가 실행중이었다면 새로 시작해주어야한다.\n\n\n\n[SASS Documentation (Ko)](https://sass-guidelin.es/ko/)\n\n[SASS Official Site](http://sass-lang.com/)\n\n\n\n\n\n---\n\n## Reference\n\n[리액트 컴포넌트 스타일링 – CSS Module / Sass / styled-components](https://velopert.com/3447)","fields":{"slug":"/js-react-apply-sass/"},"frontmatter":{"title":"React 프로젝트에 SASS 적용하기","published":true}}},{"node":{"rawMarkdownBody":"\n타 언어를 사용하다가(파이썬 제외...) 자바스크립트를 처음 접한 사람에게는 세미콜론을 쓰지 않고도 오류가 나지 않는 것을 보고 꽤나 놀랐을 것이다.\n\n\n\n\"자바스크립트에서는 세미콜론을 쓰지 않아도 오류가 나지 않는데 그렇다면 세미콜론을 쓰지 않고 짧게 작성하는게 좋지\" 라는 사람도 있다.\n\n어느쪽이 바람직 한 것일까...?\n\n\n\n우선 자바스크립트에서 세미콜론(;)을 쓰지 않아도 오류가 나지 않는 이유는  \n**ASI (Automatic Semicolon Insertion)**라는 것 때문이다.\n\n이것을 통해 엔진이 자동으로 ; 을 삽입해 주는 것이다.\n\n\n\n중요한 점은 개행, 즉 **새 줄(Line Break)에만 적용**된다는 점이다.\n\n\n\n아래 경우를 보자\n\n```javascript\nvar i = 0;\ndo {\n    console.log(i);\n} while(i===10)\ni;\n```\n\ndo-while의 경우 while끝에 ;을 붙여야 문법적으로 맞는데 깜박하더라도 ASI가 ;을 삽입해준다.\n\n```javascript\nfunction foo(){\n    if(true) return\n    console.log(\"foo\");\n}\n```\n\n위의 경우도 return 뒤에 ;을 붙여줄 것이다.  \n이 경우에는 console.log가 실행되게 할지 말지 의도한게 어떤 것인지에 따라  \n유용하게 된 경우 또는 실수에서 이어진 문제점으로 해석 될 수도 있다.\n\n\n\n세미콜론(;)을 쓰지 않더라도 유용한 ASI가 존재함에 따라 대부분은 문제가 없을 것이다.  \n그러나 초보 개발자의 실수라던가 또는 의도하지 않은 ;의 삽입으로 곤혹을 겪을 가능성이 어찌되었건 존재한다.\n\n\n\n```\n\"ASI(Automatic Semicolon Insertion) is an error correction procedure.  \nIf you start to code as if it were a universal significant-newline rule,  \nyou will get into trouble.\" —Brendan Eich\n```\n\n위는 자바스크립트의 창시자인 브렌던 아이크가 한 말이다.  \n여기서 ASI를 에러 정정 프로시저라고 말하며 이것을 보편적인 것처럼 코딩한다면 문제에 당도할 것이라고 말하고 있다.\n\n\n\n자바스크립트에서 세미콜론을 쓰는가 마는가는,  \n공백은 탭인가 스패이스인가와 같은 논쟁거리가 아니라고 생각한다.  \nASI는 에러 정정을 목적으로 만들어졌고, 아무리 적은 가능성이라도 오류가 날 가능성이 있다면,  \n글쓴이 본인은 ; 을 쓰는 것이 맞다고 생각한다.","fields":{"slug":"/js-semicolon-asi/"},"frontmatter":{"title":"자바스크립트에서 세미콜론(;)을 안써도 될까?","published":true}}},{"node":{"rawMarkdownBody":"\nJavascript는 Java와 달리 int, double 같은 숫자 타입이 나눠져있지 않다.  \nnumber 하나로 정수(Integer)와 부동 소수점 수를 모두 표현한다.\n\n\n\n### 숫자 리터럴\n\n```javascript\nvar n = 12 //12\nn = 12. //12\nn = 12.0 //12\nn = 12.300 //12.3\nn = 0.12 //0.12\nn = .12 //0.12\n```\n\n.12, 12. 과 같은 방식은 틀린 것은 아니더라도 좋은 코드라고 하긴 어려울 것이다.\n\n\n\n### Number Methods\n\n#### - Number.isInteger()\n\n정수인지 확인할 수 있는 메서드.\n\n```javascript\nvar n = 12;\nNumber.isInteger(n); // true\nn = .12;\nNumber.isInteger(n); // false\n```\n#### - Number.isSafeInteger()   **/\\*ES6\\*/**\n\n안전한 정수값인 `-(253 - 1)` 부터 `253 - 1` 사이의 정수 값인지 확인하는 메서드, ES6에서 출현하였다.\n\n```javascript\nNumber.isSafeInteger(100);                    // true\nNumber.isSafeInteger(Math.pow(2, 53));      // false\nNumber.isSafeInteger(Math.pow(2, 53) - 1);  // true\n```\n\n#### - Number.toFixed()\n\n인자로 넘긴 수 만큼의 소수점 이하를 반올림하여 문자열 형태로 반환하는 메서드.\n\n```javascript\nvar n = 12.39;\nn.toFixed(0); //\"12\"\nn.toFixed(1); //\"12.4\"\nn.toFixed(2); //\"12.39\"\nn.toFixed(3); //\"12.390\"\n```\n\n#### - Number.toPrecision()\n\n수의 길이를 제한하여 문자열로 반환한다.\n\n```javascript\nvar n = 12.39;\nn.toPrecision() //\"12.39\"\nn.toPrecision(1) //\"1e+1\"\nn.toPrecision(2) //\"12\"\nn.toPrecision(3) //\"12.4\"\nn.toPrecision(4) //\"12.39\"\n```\n\n#### - Number.toExponential()\n\n수를 지수표현식 문자열으로 반환한다.\n\n```javascript\nvar n = 10000000000;\nn; // 10000000000\nn.toExponential(); //\"1e+10\"\n```\n\n\n\n---\n\n\n\n### 0.5 === 0.2 + 0.3 // false ??\n\nJava나 타 언어를 배워봤다면 한번은 봤을만한 질문이다. \n\n0.5와 같은 부동 소수점 수는 결국 프로그래밍 언어에서는 0.5000000001과 같이 0.5와 가까운 수이기 때문이라는 것인데...\n\nJavascript에서는 어떨까?\n\n아래는 크롬 브라우저(2017.10 최신버전)의 콘솔창 결과이다.\n\n```javascript\n0.0000005 === 0.0000002 + 0.0000003;\ntrue\n0.000005 === 0.000002 + 0.000003;\nfalse\n0.00005 === 0.00002 + 0.00003;\ntrue\n0.0005 === 0.0002 + 0.0003;\ntrue\n0.005 === 0.002 + 0.003;\ntrue\n0.05 === 0.02 + 0.03;\ntrue\n0.5 === 0.2 + 0.3;\ntrue\n\n0.1 + 0.2 === 0.3\nfalse\n\n1.2 - 1 \n0.19999999999999996\n1.5 - 0.5\n1\n```\n\n모두 true 이길 바라지만 결과는 그렇지 않다. 더 어려운 것은 모두 false도 아니라는 것이다.\n\n어떤 것은 true이고 어떤 것은 false인 이러한 이유는 아직까지 정확하게 찾지 못했지만 부동 소수점 수의 계산에 있어 조심해야한다는 것을 알 수 있다.\n\n\n\n##### 해결 방법\n\n```javascript\n(1.2 - 1).toFixed(1) * 1 // 0.2\n(1.1000001 - 1).toFixed(7) * 1 // 0.1000001\n```\n\nNumber의 메서드를 사용하여 위와 같은 방법으로 해결하는 방법도 있다.\n\n","fields":{"slug":"/js-number-type/"},"frontmatter":{"title":"자바스크립트의 숫자 타입(Number Type)","published":true}}},{"node":{"rawMarkdownBody":"\n## Set\n\n중복없이 유일한 값을 저장하기 위한 타입, 이미 존재하는지 체크할때 유용하다\n\n```javascript\nlet mySet = new Set();\nconsole.log(toString.call(mySet)); // [object Set]\n\nfunction print(set){\n  set.forEach(function(value){\n    console.log(value); \n  });\n}\n\nmySet.add('a');\nmySet.add('b');\nmySet.add('a'); //저장 안됨\n\nprint(mySet); // \"a\" \"b\"\n\nconsole.log(mySet.has('b')); // true\n\nmySet.delete('a');\n\nprint(mySet); // \"b\"\n```\n\n\n\n## WeakSet\n\n참조를 가지고 있는 객체만 저장이 가능하다.\n\n참조를 가지고 있던 객체가 참조를 잃게 되면 (null 이 되거나…) 가비지컬렉션의 대상이 된다.\n\n객체를 중복없이 저장하고 활용하려할때 유용하게 쓰일 수 있다.\n\n```javascript\nlet ws = new WeakSet();\nconsole.log(toString.call(ws)); // [object WeakSet]\n\nlet arr = [1,2,3,4,5];\nlet obj = { arr };\nlet number = 100;\nfunction foo(){}\n\n//ws.add(100);\nws.add(arr);\nws.add([1,2,3,4,5]);\nws.add(obj);\n//ws.add(100);\n//ws.add(number);\n//ws.add('string')\nws.add(foo);\nws.add(function a(){});\n// 위 주석처리는 모두 에러 발생한 것들\n// TypeError: Invalid value used in weak set\n\n\narr = null;\nconsole.log(ws.has(arr)); //false\n```\n\n\n\n\n\n### map / WeakMap\n\nmap과 set의 차이는 다루는 타입과, 구조가 다르다.\n\nmap => object , key/value\nset => array\n\n이러한 차이점 이외에는 사용법은 거의 동일하다, \nWeak와 같은 경우에도 참조가 사라지면 가비지컬렉션의 대상이 되는 것도 동일하다.\n\nmap을 활용하여 따로 부가적인 정보를 저장하는 key/value를 활용할 수 있는 것 정도의 차이점이 있다.\n\n### \n\n#### WeakMap 활용\n\n프라이빗한 변수 만들기.\n\n```javascript\nconst wm = new WeakMap();\n\nfunction MyInfo(name, age){\n  wm.set(this, {name, age});\n}\n\nMyInfo.prototype.getInfo = function(){\n  const {name, age} = wm.get(this);\n  return 'name:'+name+\"/age:\"+age;\n}\n\nlet myInfo = new MyInfo('baik', 27);\n\nconsole.log(myInfo.getInfo());\n//\"name:baik/age:27\"\n\nconsole.log(wm.has(myInfo)); //true\nmyInfo = null;\nconsole.log(wm.has(myInfo)); //false\n\n//myInfo를 통해서는 name, age 값을 뽑아낼 수 없다, (private)\n```\n\n\n\n---\n\n## Reference\n\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)\n","fields":{"slug":"/js-es6-set-map/"},"frontmatter":{"title":"자바스크립트 ES6 Set, WeakSet / Map, WeakMap","published":true}}},{"node":{"rawMarkdownBody":"자바스크립트의 배열은 어떤 타입이던 담을 수 있고, 배열 크기도 미리 정하지 않는다.\n\n```javascript\nvar arr = [\n  null,\n  undefined,\n  true,\n  1,\n  \"array\",\n  {}\n];\n\nconsole.log(arr); \n// [null, undefined, true, 1, \"array\", [object Object]{...}]\n\nconsole.log(typeof arr, toString.call(arr));\n//'object', '[object Array]'\n```\n\n\n\n### 배열에서 빈 슬롯의 주의점\n\n배열에서 주의 해야할 점은 중간에 빈 구멍이 있는 배열을 조심해야 한다.\n\n```javascript\nvar arr = [];\narr[0] = 1;\narr[2] = 2;\narr[3] = undefined;\n```\n\n위와 같은 코드가 있을때 배열의 1번은 비어있을 것이다. 어떤 배열이 되어있을지 보면\n\n```javascript\nconsole.log(arr); //[1, undefined, 2, undefined]\nconsole.log(arr.length); // 4\n```\n\n위와 같이 되어있다. 비어있는 배열이 undefined가 되어있다.\n1번 undefined와 따로 선언한 undefined의 3번은 서로 같은 것인 것일까?\n\n```javascript\nconsole.log(arr[1] === arr[3])\nconsole.log(typeof arr[1] === typeof arr[3]);\nconsole.log(toString.call(arr[1]) === toString.call(arr[3]));\nconsole.log(arr[1] === undefined);\nconsole.log(arr[3] === undefined);\n```\n\n이렇게 비교를 해 보아도 모두가 **true** 로 일치한다고 나온다 하지만\n빈 슬롯이 undefined과 된 것과 선언으로 인해 undefined 인 것은 **엄연히 다르다.**\n\n그 이유는 아래에서 알 수 있다.\n\n```javascript\nconsole.log(arr);\n[1, undefined, 2, undefined]\n\nfor(index in arr){\n  console.log(index);\n}\n// 0, 2, 3\n\nvar newArr = [];\narr.forEach(function(value, index){\n  console.log(\"index:\"+index+\"/value:\"+value);\n  newArr.push(value);\n})\n// \"index:0/value:1\"\n// \"index:2/value:2\"\n// \"index:3/value:undefined\"\n\nconsole.log(newArr);\n// [1, 2, undefined]\n```\n\nfor in, forEach 등을 통해 실험을 해 본 결과이다.\nfor in 에서는 index 1이 존재하지 않는 것으로 보이고,\nforEach를 통해서도 새로운 배열을 복사하는 것을 하려 했으나 1번 배열이 빠진채로 수행 된 것을 볼 수 있다.\n\n이러한 예제를 통해 빈 슬롯이 있는 배열을 다루게 된다면 조심해야한다는 것을 알 수 있다.\n\n\n\n### 배열의 key/property 형태의 활용\n\n배열 인덱스는 숫자이다. 그런데 배열도 객체이기 때문에 key/property 문자열을 추가 할 수 있다.\n\n```javascript\nvar arr = [];\n\narr[0] = 1;\narr[\"two\"] = 2;\n```\n\n조심해야할 점은 이렇게 선언할 경우 배열의 길이는 늘어나지 않는 것을 조심해야한다. 또한 배열을 출력할 경우 나타나지 않는다.\n\n```javascript\nconsole.log(arr); // [1]\nconsole.log(arr[\"two\"]); // 2\n\nconsole.log(arr.length); // 1\n\nfor(index in arr){\n  console.log(index);\n} // '0'\n```\n\n더욱 조심해야 할 점은 키로 넣은 문자열이 표준 10진수 숫자로 이루어져 있다면 아래와 같은 결과를 얻게 된다.\n\n```javascript\narr[\"5\"] = \"five\";\nconsole.log(arr);\n//[1, undefined, undefined, undefined, undefined, \"five\"]\nconsole.log(arr.length); // 6\n\nfor(index in arr){\n  console.log(index);\n} // '0', '5', 'two'\n```\n\n키/프로퍼티 형태로 활용하는 것을 지양하고 이렇게 써야한다는 상황이라면 문자열 프로퍼티는 꼭 숫자가 아닌 글자만 사용하도록 하자.\n\n\n\n### 유사배열\n\n유사배열을 진짜 배열로 바꾸는 방법\n\n일반적으로 indexOf, concat, forEach 등의 배열 함수들을 사용한다, \n또한 slice를 활용한 방법도 있다\n\n```javascript\nfunction test(){\n  var arr = Array.prototype.slice.call( arguments );\n  return arr;\n}\n\nvar a = test('a', 1);\nconsole.log(toString.call(a), a); \n//\"[object Array]\" [\"a\", 1]\n```\n\nES6에 와서는 유사 배열을 진짜 배열로 바꾸는 기능이 추가되었다. \n`Array.from()`\n\n```javascript\nfunction test(){\n  var arr = Array.from( arguments );\n  return arr;\n}\n\nvar a = test('a', 1);\nconsole.log(toString.call(a), a); \n//\"[object Array]\" [\"a\", 1]\n```","fields":{"slug":"/js-array/"},"frontmatter":{"title":"자바스크립트의 배열(Array)","published":true}}},{"node":{"rawMarkdownBody":"\n## Javascript Variable Types\n\n\n자바스크립트의 변수는 모든 데이터 타입을 수용할 수 있도록 되어있다.\n\n`typeof` 라는 특정 변수의 데이터 타입을 확인하여 문자열로 반환하는 연산자가 있다.\n\n\n\n- **값은 타입을 가진다 / 변수에는 따로 타입이란 없다**\n  변수는 언제라도 어떤 형태의 값이라도 가질 수 있다.\n  `var a = '123'`\n  변수 a는 string 타입이다 (X)\n  변수 a의 값으 string 타입이다 (O) //정확한 표현\n\n  ​\n\n### Standard defines seven data types\n\n1. Six data types that are primitives\n  1. Boolean\n  2. Null\n  3. Undefinend\n  4. Number\n  5. String\n  6. Symbol\n2. and Object\n\n\n\n\n… symbol 은 ES6부터 출현한 타입\n\n… object를 제외한 나머지 타입을 원시 타입(primitives)이라 한다\n\n\n\n### typeof results\n\n\n| Type             | 'typeof' Result |\n| ---------------- | --------------- |\n| number           | number          |\n| string           | string          |\n| boolean          | boolean         |\n| undefined        | undefined       |\n| null             | **object**      |\n| symbol           | symbol          |\n| function object  | function        |\n| any other object | object          |\n\n\n\n- **typeof null === 'object' //… true ??**\n\n자바스크립트에서는 null 이 기본형으로 구분되어있다.\n하지만 typeof null의 결과로는 null이 반환되지 않고 object가 반환되는 이유는 자바스크립트 개발 당시 다른 언어들과 같이 null이 0값을 가지고 있는 객체로 취급하여 object를 반환하도록 개발되었기 때문이다.\nnull값이 기본형이므로 반환값을 null로 바꾸자는 의견도 많으나 이미 object 반환 방식으로 구현된 웹들이 많아 쉽게 바꾸지 못하고 있다.\n\nnull을 확인하기 위한 방법으로는 (var a = null)\n`!a && typeof a === 'object'`\n\n- **typeof function a(){} // function**\n\ntypeof가 반환하는 값 중 7가지 타입이 아닌 것이 하나 있는데 그것이 function이다.  function은 object의 하위 타입으로 함수가 객체라서 유용한 점으로는 property를 들 수 있다, a.length로 property의 갯수를 알 수 있다.\n\n- **배열…?**\n\ntypeof [1,2,3] // 'object' 이다.\n배열도 객체이기 때문이다, 숫자 인덱스를 가지고 length 프로퍼티가 자동으로 관리되는 등 추가 특성을 가진 객체의 하위 타입이라 할 수 있다.\ntoString.call([1,2,3]) 을 사용하면 [object Array]의 반환값을 얻어 구체적으로 타입을 알 수 있어 배열인지 알 수 있게 된다.\n\n\n\n### undefined\n\n```javascript\nvar a;\nconsole.log(a); //undefined\nvar b = 1;\nconsole.log(b); //1\nvar c;\nconsole.log(c); //undefined\nb = c;\nconsole.log(b); //undefined\nconsole.log(d); //ReferenceError: d is not defined\n```\n\n위의 코드를 보면\n\nundefined (값이 없는), undefined(선언되지 않은) 은 자바스크립트에서는 전혀 다르다는 것을 알 수 있게 된다.\n\n\n\n```javascript\nvar a;\nvar b = 1;\nconsole.log(typeof a); //undefined\nconsole.log(typeof b); //undefined\nconsole.log(typeof c); //undefined\n```\n\n위의 코드를 보면 typeof는 값이 없는, 선언되지 않은 것 모두가 undefined 으로 표시된다.\n\ntypeof로는 둘을 구분 할 수 없지만 이렇게 에러가 발생하지 않는 특성(안전가드라고 한다)을 이용하여 유용하게 사용하는 방법도 있다.","fields":{"slug":"/js-variable-types/"},"frontmatter":{"title":"자바스크립트의 타입들","published":true}}},{"node":{"rawMarkdownBody":"\nProxy : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n\n\n\n```javascript\nconst myInfo = {\n  name: 'baik'\n};\n\nconst proxy = new Proxy(myInfo, {});\n// Proxy(object, handler);\n\nconsole.log(toString.call(proxy)); // object\n\n\nconsole.log(proxy.name); // baik\nproxy.name = 'junho';\nconsole.log(proxy.name); // junho\nconsole.log(myInfo.name); // junho\n\n\nconsole.log(proxy === myInfo); // false\nconsole.log(proxy.name === myInfo.name); // true\n```\n\n\n\n```javascript\nconst myInfo = {\n  name: 'baik',\n  change: 0\n};\n\nconst proxy1 = new Proxy(myInfo, {});\n\nconst proxy2 = new Proxy(myInfo, {\n  get: function(target, property, receiver){\n    console.log(\"get\");\n    return target[property];\n  },\n  set: function(target, property, value){\n    console.log(\"set\");\n    target['change']++;\n    target[property] = value;\n  }\n  // target => myInfo\n  // receiver => proxy2\n});\n\n\nconsole.log(proxy1.name); // \"baik\"\nconsole.log(proxy2.name); // \"get\" \"baik\"\nconsole.log(proxy2.change); // \"get\" 0\nproxy2.name = 'junho'; // \"set\"\nconsole.log(proxy2.name); // \"get\" \"junho\"\nconsole.log(proxy2.change); // \"get\" 1\nconsole.log(myInfo.name); // \"junho\"\n\n//porxy의 getter setter를 통해서 값을 가로채서 값을 변화시킨다거나,\n//변경사항 로그를 남기는 등의 용도록 활용할 수 있다.\n```\n\n\n\n권장되는 패턴\n\n```javascript\nconst proxy = new Proxy(myInfo, {\n  get: function(target, property, receiver){\n    //...\n    return Reflect.get(target, property);\n    // Reflect 활용\n  },\n```\n\n\n\n\n\n\n\n---\n\n## reference\n\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","fields":{"slug":"/js-es6-proxy/"},"frontmatter":{"title":"자바스크립트 ES6 프록시(Proxy)","published":true}}},{"node":{"rawMarkdownBody":"\nsetPrototypeOf 로 프로토타입 객체를 추가 할 수 있다.  \n`Object.setPrototypeOf(obj, prototype)`  \nobject에 prototype을 추가한다.\n\n\n\n```javascript\nconst infoObj = {\n  sayHi : function(){\n    console.log(\"Hi \" + this.name)\n  },\n  setName : function(name){\n      this.name = name;\n  }\n};\n\nconst myInfo = {\n  name : \"Baik\",\n  msg : \"Hi\"\n};\n\nObject.setPrototypeOf(myInfo, infoObj);\n\nconsole.log(myInfo.sayHi());\n//Hi Baik\n\nmyInfo.setName(\"Baek\");\n\nconsole.log(myInfo.sayHi());\n```\n\n\n\n\n\n### setPrototypeOf 로 개체간 prototype Chain 만들기\n\n\n\n```javascript\nconst infoObj = {\n  sayHi : function(){\n    console.log(\"Hi \" + this.name)\n  },\n  setName : function(name){\n      this.name = name;\n  }\n};\n\nconst infoChildObj = {\n  getAge : function(){\n    return this.age;\n  }\n}\n\nconst myInfo = Object.setPrototypeOf({\n  age : 22\n}, infoChildObj);\n// Chain = infoChildObj - myInfo\n\nconsole.log(myInfo);\n// age, getAge\n\nObject.setPrototypeOf(infoChildObj, infoObj);\n// Chain = infoObj - infoChildObj - myInfo\n\nconsole.log(myInfo);\n// age, getAge, sayHi, setName\n\ninfoObj.sayAge = function(){\n  console.log(\"Age is \" + this.age)\n}\n// infoObj에 sayAge를 추가함으로 myInfo에 까지 영향을 미치게된다.\n\nconsole.log(myInfo);\n//age, getAge, sayAge, sayHi, setName\n\n\n```\n\n\n\n---\n\n## reference\n\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","fields":{"slug":"/js-es6-setprototypeof/"},"frontmatter":{"title":"자바스크립트 ES6 Object setPrototypeOf","published":true}}},{"node":{"rawMarkdownBody":"\nES6에서 출현한 module 기능은 브라우저 호환성이 아직은 완전하지 않다.  \ndevOps로 webpack, babel 등을 활용해 사용해 서비스 코드를 만드는 것이 좋다.\n\n\n\n### 기본 사용법\n\napp.js\n\n```javascript\nimport foo from './foo';\n\n// ...\n\nprint('Hello World'); // Hello World\n```\n\nfoo.js\n\n```javascript\nexport function print(value){\n    console.log(value);\n}\n```\n\n\n\n\n\n### 심화, 서비스 코드 구현\n\napp.js\n\n```javascript\nimport sayHi, { print, getTime, myInfo } from './foo';\n//default로 지정한 것은 {}바깥, 그렇지 않은 것들은 {}안에 위치한다.\n\n// ...\n\nprint('Hello World'); // Hello World\ngetTime(); // \n\nconst me = new myInfo();\nprint(`My Name is ${getFullName()}`);\n// My Name is Junho Baik\n```\n\nfoo.js\n\n```javascript\nexport function print(value){\n    console.log(value);\n}\n\nexport const getTime = () => {\n    return Date.now();\n}\n\nexport class myInfo {\n    constructor(props){\n        this.name = [\"Junho\", \"Baik\"];\n    }\n  \n    getFullName(){\n        return this.name[0] + \" \" + this.name[1];\n    }\n}\n\nconst sayHi = () => {\n    console.log(\"Hi!\");\n}\nexport default sayHi;\n// export defalut const sayHi... 이와 같이는 쓸 수 없다.\n```\n\n\n\n\n```javascript\nexport const _ = {\n    print(value){\n        if(window.console) console.log(value);\n    }\n  \t\n  \t// ...\n}\n\n// 위와 같은 방식으로 사용하여\n_.print(\"ABC\"); // 이와같이 사용하는 방법 또한 있다.\n```\n\n\n\n---\n\n## reference\n\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","fields":{"slug":"/js-es6-module/"},"frontmatter":{"title":"자바스크립트 ES6 module(export&import)","published":true}}},{"node":{"rawMarkdownBody":"\n자바스크립트에도 이번 ES6에서 Class라는 키워드가 생겼다.\n\n\n\n아래는 기존 자바스크립트의 코드이다.\n\n```javascript\nfunction myInfo(name) {\n    this.name = name;\n}\n\nmyInfo.prototype.showName = function(){\n    console.log(\"My name is \"+ this.name);\n}\n\nconst baik = new myInfo(\"Junho\");\nbaik.showName(); // \"My name is Junho\"\n```\n\n\n\n아래는 Class를 활용한 코드이다.\n\n```javascript\nclass myInfo {\n  constructor(name){\n    this.name = name;\n  }\n  \n  showName() {\n    console.log(\"My name is \"+ this.name);\n  }\n}\n\nconst baik = new myInfo(\"Junho\");\nbaik.showName(); //\"My name is Junho\"\n```\n\n위와 같이 클래스로 똑같은 코드를 구현할 수 있다. 하지만 그렇다고 클래스라는 것이 완전히 새로 생긴 것이 아니고 위와 같이 했더라도 내부적으로는 함수, 프로토타입을 통해 작동하는 것이다.\n\n```javascript\nconsole.log(toString.call(myInfo)); //[object Function]\n```\n\n이번에 ES6에서 편의와 가독성을 위해 class라는 키워드가 생긴 것이라고 볼 수 있다.\n\n\n---\n\n## reference\n\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","fields":{"slug":"/js-es6-class/"},"frontmatter":{"title":"자바스크립트 ES6 클래스(Class)","published":true}}},{"node":{"rawMarkdownBody":"\n아래 코드는 Object create를 사용한 코드이다.\n\n```javascript\nconst infoObj = {\n  showName : function(){\n    console.log(\"My name is \" + this.name);\n  }\n}\n\n//아래와 같은 방법으로 프로토타입을 사용한 것 보다 간결하게 나타낼 수 있다.\nconst myInfo = Object.create(infoObj);\n\nmyInfo.name = \"Junho\";\nmyInfo.age = 27;\n\nconsole.log(myInfo);\n/*\n{name: \"Junho\", age: 27}\n  age:27\n  name:\"Junho\"\n  __proto__: \n    showName: ƒ showName()\n    __proto__:Object\n*/\nconsole.log(myInfo.showName()); //\"My name is Junho\"\n```\n\n\n\n아래 코드는 위의 코드에 Object assign을 사용한 코드이다.\n\n`myInfo.name = \"Junho\";` 와 같이 계속해서 추가해야하는 수고를 덜어줄 수 있다.\n\n```javascript\nconst infoObj = {\n  showName : function(){\n    console.log(\"My name is \" + this.name);\n  }\n}\n\nconst myInfo = Object.assign(Object.create(infoObj), {\n  name : \"Junho\",\n  age : 27\n});\n\n\nconsole.log(myInfo);\nconsole.log(myInfo.showName());\n```\n\n\n\n\n\n## Object assign 으로 Immutable 객체 만들기\n\n```javascript\nconst previousObj = {\n  name : \"Junho\",\n  age : 27\n};\n\nconst myInfo = Object.assign({}, previousObj, {\n  name : \"Baik\",\n  msg : \"Hi\"\n});\n\nconst myInfo2 = Object.assign({}, previousObj, {});\n\n\nconsole.log(previousObj); //{name: \"Junho\", age: 27}\n\nconsole.log(myInfo); //{name: \"Junho\", age: 27}\nconsole.log(previousObj === myInfo); //false\n\nconsole.log(myInfo2); //{name: \"Junho\", age: 27}\nconsole.log(previousObj === myInfo2); \n//false\n//내용은 같으나 사실상 다른 객체이다, immutable object\n```\n\n\n\n---\n\n## reference\n\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","fields":{"slug":"/js-es6-object-assign/"},"frontmatter":{"title":"자바스크립트 ES6 Object.assign","published":true}}},{"node":{"rawMarkdownBody":"\nES6 에 출현한 새로운 형태의 함수 표현 방법\n\n```javascript\nconst fn = function(){};\nconst arrowFn = () => {};\n\n(v) => (v+1) //{}없이 사용, v+1이 리턴값\n(v) => v+1 //()생략 가능\n```\n\n\n\n### Arrow Function, this context\n\n```javascript\nconst obj = {\n  runTimeout() {\n    setTimeout(function(){\n      console.log(toString.call(this)); //[object Window]\n    }, 1000);\n  },\n  \n  sayHi(){\n    console.log(\"hi\");\n    console.log(toString.call(this));\n  }\n}\n\nobj.runTimeout(); //[object Window]\nobj.sayHi(); // hi [object Object]\n```\n\n위의 코드는 아무런 문제 없이 작동하는 코드이다, runTimeout은 settimeout때문에 이벤트큐에 등록 된뒤 실행되는 것이라 this가 해당 오브젝트가 아닌 윈도우이다. 우선 위에서 this가 가리키는 것이 무엇인지 잘 봐두고, 문제가 될 수 있는 상황을 아래서 살펴보자\n\n```javascript\nconst obj = {\n  runTimeout() {\n    setTimeout(function(){\n      console.log(toString.call(this));\n      this.sayHi(); //<========\n      //typeError: this.sayHi is not a function\n    }, 1000);\n  },\n  \n  sayHi(){\n    console.log(\"hi\");\n    console.log(toString.call(this));\n  }\n}\n\nobj.runTimeout();\n```\n\nrunTimeout 에서 sayHi를 실행하려면 this가 가리키는 것이 서로 다르기 때문에 오류가 난다.\n\n```javascript\nconst obj = {\n  runTimeout() {\n    setTimeout(function(){\n      console.log(toString.call(this)); //[obejct Object]\n      this.sayHi();\n    }.bind(this), 1000); //<========\n  },\n  \n  sayHi(){\n    console.log(\"hi\");\n    console.log(toString.call(this)); //[obejct Object]\n  }\n}\n\nobj.runTimeout(); // [obejct Object] hi [obejct Object]\n```\n\n위와 같이 .bind(this) 를 사용하여 해결하는 방법이 있다.\n\n```javascript\nconst obj = {\n  runTimeout() {\n    setTimeout(()=>{ //<========\n      console.log(toString.call(this));\n      this.sayHi();\n    }, 1000);\n  },\n  \n  sayHi(){\n    console.log(\"hi\");\n    console.log(toString.call(this));\n  }\n}\n\nobj.runTimeout();\n```\n\n또 다른 방법으로 Arrow function을 이용하여 해결할 수 있다.\n\nArrow function은 항상 this context를 실행되는 해당 context를 유지하는 특성이 있다.\n\n\n\n---\n\n## reference\n\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","fields":{"slug":"/js-es6-arrow-function/"},"frontmatter":{"title":"자바스크립트 ES6 Arrow Function","published":true}}},{"node":{"rawMarkdownBody":"\n\n\n쉽게 말해 배열을 펼쳐주는 역할이다. ''[ ]''를 떼어낸다고 생각하면 쉽다.  \n배열을 바꾸지 않고 새로운 값을 복사, 배열을 합치거나 배열을 펼쳐진 상태로 파라메터로 전달 등의 활용이 가능하다.\n\n\n\n```javascript\nlet a = [1,\"\",undefined,NaN,null];\nlet b = [...a];\n\nconsole.log(a); //[1, \"\", undefined, NaN, null]\nconsole.log(b); //[1, \"\", undefined, NaN, null]\n\nconsole.log(a === b); //false\n// 새로운 배열로 메모리에 들어간 복사를 한 형태, \n// concat을 이용한 것과 같은 결과이다.\n// 배열을 바꾸지 않고 새로운 값을 복사할 수 있는 방법.\n```\n\n\n\n```javascript\nlet c = [...a, 'add'];\nconsole.log(c); //[1, \"\", undefined, NaN, null, \"add\"]\n// 기존에 복잡한 과정을 거쳐했던 것을 간단하게 \n// 이러한 방식으로 배열 앞뒤에 새로운 것을 추가할 수 있다.\n```\n\n\n\n```javascript\nfunction sum(a,b,c){\n  return a+b+c;\n}\n\nlet s = [1,2,3];\n\nconsole.log(sum.apply(null,s)); \n// 기존 방식\n\nconsole.log(sum(...s)); \n// spread operator를 이용한 새로운 방식\n```\n\n","fields":{"slug":"/js-es6-spread-operator/"},"frontmatter":{"title":"자바스크립트 ES6 Spread operator, 펼침 연산자","published":true}}},{"node":{"rawMarkdownBody":"\nJavascript에서는 배열로 보이지만 정작 배열이 아닌 형태의 것들이 존재한다.\n\n예로 메소드로 전달되는 인자들을 활용하는 arguments 객체같은 경우에도 배열같아보이지만 실제 배열은 아니다.\n따라서, map과 같은 배열을 다루는 메소드를 활용할 수 없는데 이러한 가짜 배열을 진짜배열로 바꿔주는 것을 from 이 해주게 된다.\n\n\n\n```javascript\nfunction toArray(array){\n  const len = array.length;\n  const temp = [];\n  \n  for(let i=0; i<len; i++){\n    temp.push(array[i]);\n  }\n  \n  return temp;\n}\n\nfunction toArray2(array){\n  return array.map(function(value){\n    return value;\n  })\n}\n\n\nfunction foo() {\n  \n  console.log(toString.call(arguments)); \n  // [object Arguments]\n  \n  console.log(toArray(arguments));\n  // [1, 2, 3, 4, 5]\n  \n  //console.log(toArray2(arguments));\n  // map 사용시 배열이 아니기 떄문에 오류 발생\n  \n  /*************************************/\n  \n  let newArray = Array.from(arguments);\n  \n  console.log(toString.call(newArray));\n  // [object Array]\n  \n  console.log(toArray(newArray));\n  // [1, 2, 3, 4, 5]\n  \n  console.log(toArray2(newArray));\n  // [1, 2, 3, 4, 5]\n}\n\nfoo(1,2,3,4,5);\n```\n\n\n\n위 코드에서 toArray2 메소드는 map을 활용하여 배열을 반환한다.\n\n하지만 arguments를 인자로 전달했을때는 에러가 발생하는 것을 볼 수 있다.","fields":{"slug":"/js-es6-from/"},"frontmatter":{"title":"자바스크립트 ES6 from","published":true}}},{"node":{"rawMarkdownBody":"\n- [String.prototype.startsWith()][https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith]\n  - 문자열이 특정 문자로 시작하는지 확인, 결과를 true, false로 반환.\n- [String.prototype.endsWith()][https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith]\n  - 문자열이 특정 문자로 끝나는지 확인, 결과를 true, false로 반환.\n- [String.prototype.includes()][https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/includes]\n  - 문자열에 특정 문자열이 포함되는지 확인, 결과를 true, false로 반환.\n\n```javascript\nlet str = 'javascript es6 string methods';\n\nconsole.log(str.startsWith('javascript')); //true\nconsole.log(str.endsWith('methods')); //true\nconsole.log(str.includes('es6')); //true\n```\n\n\n\n- [String.prototype.repeat()][https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/repeat]\n  - 문자열을 인자만큼 반복하는 문자열을 반환\n\n```javascript\nlet str = 'es6';\n\nconsole.log(str.repeat(3)); //es6es6es6\n```\n\n\n\n\n\n---\n\n## Reference\n\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","fields":{"slug":"/js-es6-string-methods/"},"frontmatter":{"title":"자바스크립트 ES6 String Methods","published":true}}},{"node":{"rawMarkdownBody":"\n## Javascript 'For Loop'\n\n자바스크립트에서 사용하는 for 반복문의 유형에 대해 알아보자.\n\n- for\n   - `for ([initialization]; [condition]; [final-expression])`\n- for in\n   - `for (variable in [object | array])`\n- for of (ES6)\n   - `for (variable of object)`\n\n---\n\n### - for\n\n`for ([initialization]; [condition]; [final-expression])`\n\n### - for in\n\n`for (variable in [object | array])`\n\n- variable\n 1. object 일때 variable = object의 다음 속성 이름\n 2. array 일때 variable = array의 다음 요소 인덱스\n\n### - for of (ES6)\n\n`for (variable of object)`\n\n- variable\n 1. object의 임의 속성 **값**일 수 있는 변수입니다.\n\n\n```javascript\nconst arr = [1,\"\",undefined,NaN,null];\n\n/**************************************/\n\nfor(let index = 0; index < arr.length; index++){\n  console.log(arr[index]);\n}\n// 1\n// \"\"\n// undefined\n// NaN\n// null\n\n\n/**************************************/\n\n\nfor(let index in arr){\n  console.log(\"index:\" + index + \" / arr[index]:\" + arr[index]);\n}\n// index:0 / arr[index]:1\n// index:1 / arr[index]:\"\"\n// index:2 / arr[index]:undefined\n// index:3 / arr[index]:NaN\n// index:4 / arr[index]:null\n\n\n/**************************************/\n\n\nfor(let value of arr){\n  console.log(value);\n}\n// 1\n// \"\"\n// undefined\n// NaN\n// null\n```\n\n\n\n### for of / for in 의 차이점\n\n배열일 경우 배열 전체를 순회하는 반복문인 것은 같지만 차이점이 있다.\n\n여기서 ES6에서 새로 나온 for of 의 장점을 발견 할 수 있다.\n\n\n아래 코드를 살펴보면 Array의 prototype에 foo라는 새로운 메소드를 정의해놓았다.\n그런데 arr를 for in문을 통해서 콘솔 출력한 결과 foo라는 메소드까지 같이 출력되는 것을 볼 수 있다.\n하지만 for of는 그렇지 않다, 온전히 자신의 것만 출력할 수 있다.\n\n```javascript\nconst arr = [1,\"\",undefined,NaN,null];\nArray.prototype.foo = function(){};\n\nfor(let index in arr){\n  console.log(\"index:\" + index + \" / arr[index]:\" + arr[index]);\n}\n// index:0 / arr[index]:1\n// index:1 / arr[index]:\"\"\n// index:2 / arr[index]:undefined\n// index:3 / arr[index]:NaN\n// index:4 / arr[index]:null\n// index:foo / arr[index]:function () {}\n\nfor(let value of arr){\n  console.log(value);\n}\n// 1\n// \"\"\n// undefined\n// NaN\n// null\n```\n\n","fields":{"slug":"/js-for-loop/"},"frontmatter":{"title":"자바스크립트 for문들의 유형과 차이점","published":true}}},{"node":{"rawMarkdownBody":"\nES6 (ES2015) 에서는 새로운 선언 방법이 생겼는데,  \n그것이 const와 let이다.  \n기존에 다른 프로그래밍 언어를 사용하고 왔다면 처음 var 를 접할때 당황스러운 점을 느껴본 적이 있을 것이다. var의 관대함 때문이다. 그런 것을 비교하며 살펴보겠다.\n\n```javascript\n//case 1\nconsole.log(a);\nvar a;\n\n//case 2\nconsole.log(a);\nlet a;\n\n//case 3\nconsole.log(a);\nconst a;\n```\n\n해당 변수를 선언하기 전에 호출하는 모습이다.\n\n- case 1 : `undefined`\n- case 2 & 3 : `error`\n\n\n\n```javascript\n//case 1\nvar a = 'a';\nvar a = 'A';\n\n//case 2\nlet b = 'b';\nlet b = 'B';\n\n//case 3\nconst c = 'c';\nconst c = 'C';\n```\n\n위의 세 경우를 보자 같은 이름의 변수를 다시금 선언하고 있는 모습이다.\n\n- case 1 : `a=1`\n- case 2 & 3 : `error`\n\n\n\n**위의 두가지 경우를 통해서 let, const는 기존의 var의 관대함 없이 엄격해진 것을 볼 수 있다**\n\n\n\n### scope\n\n다음으로 스코프, 즉 유효 범위에 따른 차이점이다.\n\n```javascript\n//case 1\nvar a = 'a';\nfunction print(){\n  var a = 'A';\n  console.log(a);\n}\nprint(); // 'A'\nconsole.log(a); // 'A'\n\n//case 2\nlet a = 'a';\nfunction print(){\n  let a = 'A';\n  console.log(a);\n}\nprint(); // 'A'\nconsole.log(a); // 'a'\n```\n\n- case 1\n  - 함수 밖에서 a 선언, 그리고 함수 안에서 재선언되었다.\n  - 함수 안 a 출력은 함수 안에서 선언한 'A'가 출력\n  - 함수 밖 a 출력은 함수 안에서 재선언한 'A'가 출력\n  - 즉, 동일한 유효범위 안에 있다.\n- case 2\n  - 함수 밖에서 a 선언, 그리고 함수 안에서 선언.\n  - 함수 안 a 출력은 함수 안에서 선언한 'A'가 출력\n  - 함수 밖 a 출력은 함수 밖에서 선언한 'a'가 출력\n  - 즉, 서로 다른 유효범위를 가지고 있다.\n  - let, const는 블록 유효범위(Block scope)를 가지고 있어,\n    해당 블록 범위 안에서만 유효하다.\n\n\n\n\n### let, const 의 차이점\n\nvar 와 let, const의 차이점을 알아보았고, 그렇다면 let, const의 차이점은 무엇일까?\n\n- const \n  - 상수\n  - 초기값 필요 / 값 재할당 불가\n  - Array, Object, function의 경우 멤버값 조작 가능\n- let\n  - 초기값 불필요 / 값 재할당 가능\n\n\n\n\n### let, const 의 사용\n\n그렇다면 언제 let을 사용하고 const를 사용해야 할까?\n\n- const\n  - 값이 수정되지 않는 상수값 선언시 사용\n  - array, object, function 활용시 사용\n- let\n  - 값을 재할당할 필요가 있는 변수에 사용\n\n\n\n\n---\n\n### etc.\n\n#### immutable array 만들기 (불변의 어레이 만들기)\n\n```javascript\nconst list = [1,2,3];\n\nconst list2 = list;\nlist2.push(4);\n\n// 원하는 결과\n// list = [1,2,3]\n// list2 = [1,2,3,4]\n// 'list === list2' 가 false\n\nconsole.log('1, '+list);\nconsole.log('2, '+list2);\nconsole.log(list === list2);\n\n// 실제 결과\n// list = [1,2,3,4]\n// list2 = [1,2,3,4]\n// 'list === list2' 가 true\n\n// 원하는 결과를 얻기 위한 방법\nconst newlist = [1,2,3]\nconst newlist2 = [].concat(newlist);\nnewlist2.push(4);\n\nconsole.log('1, '+newlist);\nconsole.log('2, '+newlist2);\nconsole.log(newlist === newlist2);\n\n// newlist = [1,2,3]\n// newlist2 = [1,2,3,4]\n// 'newlist === newlist2' false\n```\n\n\n\n\n\n---\n\n## References\n- http://blog.nekoromancer.kr/2016/01/26/es6-var-let-%EA%B7%B8%EB%A6%AC%EA%B3%A0-const/","fields":{"slug":"/js-es6-const-let/"},"frontmatter":{"title":"자바스크립트 ES6 const, let","published":true}}},{"node":{"rawMarkdownBody":"\n![출처 : https://velopert.com/1130](https://velopert.com/wp-content/uploads/2016/03/Screenshot-from-2016-12-10-00-21-26-1.png)\n\n\n## - Mount\n\n컴포넌트가 실행 될 때, 'Mount 된다' 라고 표현.\n\n컴포넌트가 시작되면 제일 초기의 작업은\n\n1. context, defaultProps, state 저장\n2. componentWillMount 메소드 호출\n3. render, 컴포넌트를 DOM에 그린다.\n4. componentDidMount 호출\n\n---\n\n## - 기본적인 컴포넌트 생성 과정\n\n### constructor\n\n```javascript\nconstructor(props){\n\tsuper(props);\n}\n```\n\n컴포넌트가 처음 만들어 질 때 **가장 먼저** 실행되는 메소드\n\n\n### componentWillMount\n\n```javascript\ncomponentWillMount(){\n}\n```\n\n컴포넌트가 DOM 위에 만들어지기 전에 실행된다,\n\n- componentWillMount 중 주의할 점\n  - 현재 Mount 진행 중이므로(DidMount 전이다), props나 state를 변경해서는 안된다.\n  - 또한 render 단계에 진입하지 않았으므로 DOM에 접근 할 수 없다.\n\n\n### componentDidMount\n\n```javascript\ncomponentDidMount(){\n}\n```\n\n컴포넌트가 만들어지고 난 후 render를 거치고 실행되는 메소드.\n\n여기서 javascript framework 연동, setTimeout, setInterval 및 AJAX 처리를 한다.\n\n- componentDidMount 에서 주의할 점\n  - render가 되었으므로 DOM에 접근 할 수 있지만,\n    state를 바꾸면 안된다. setState메소드를 사용하면 render 메소드가 다시 실행되기 때문이다.\n    방금 render를 마친 단계인데, 다시금 render가 실행되면 사용자에게 표시될때 깜박임 등을 유발 할 수 있게 된다.\n\n---\n\n\n\n## - Props Update 에 따른 cycle\n\nprops가 업데이트 될 때의 사이클,\n\n업데이트 되기 전, 업데이트를 감지 우선 **componentWillRecieveProps** 메소드 호출.\n\n다음으로 **shouldComponentUpdate, componentWillUpdate**가 차례로 호출.\n\n업데이트(render)가 완료되면 componentDidUpdate가 실행된다.\n\n여기서 componentDidUpdate는 이미 업데이트 된 상태이다, 따라서 바뀌지 이전의 props에 대한 정보를 가지고 있다.\n\n메소드들의 첫번째 인자로 props에 대한 정보를 가지고 있다.\n\n\n\n1. componentWillRecieveProps\n2. shouldComponentUpdate\n3. componentWillUpdate\n4. render\n5. componentDidUpdate\n\n\n\n###  componentWillRecieveProps\n\n```javascript\ncomponentWillRecieveProps(nextProps){\n  \n}\n```\n\n컴포넌트가 props를 새로 받았을 때 실행.\n\nprop에 따라 state 를 업데이트 해야 할 때 사용하면 유용하다.\n\n- componentWillRecieveProps 단계에서 주의 할 점\n  - setState를 할 때 추가적으로 렌더링 하지 않는다\n\n### shouldComponentUpdate\n\n```javascript\nshouldComponentUpdate(nextProps, nextState){\n  var foo = nextProps !== this.props;\n  return foo;\n}\n```\n\nprop 또는 state가 변경되었을때, 다시 render를 할지 결정하는 메소드.\n\nreturn 값 boolean으로 결정된다.\n\n\n\n###  componentWillUpdate\n\n```javascript\ncomponentWillUpdate(nextProps, nextState){\n    \n}\n```\n\n컴포넌트가 업데이트 되기 전에 실행.\n\n- 주의사항\n  - setState 사용 시 무한 루프 발생\n\n\n\n### componentDidUpdate\n\n```javascript\ncomponentDidUpdate(prevProps, prevState){\n    \n}\n```\n\nrender를 마친 후 실행된다.\n\n변경되고 난 후 이므로 변경 전의 prop, state를 가지고 있다.\n\n\n\n---\n\n\n\n## - State Update 에 따른 cycle\n\nsetState를 통해서 state가 업데이트 될 때의 과정.\n\nprops update와 과정은 동일하나 componentWillRecieveProps 메소드는 호출되지 않는다.\n\n메소드들의 두번째 인자로 state에 대한 정보를 가지고 있다.\n\n\n\n1. shouldComponentUpdate\n2. componentWillUpdate\n3. render\n4. componentDidUpdate\n\n\n---\n\n\n\n## - Unmount\n\nUnmount, 컴포넌트가 제거되는 것.\n\n\n\n1. componentWillUnmount\n\n### componentWillUnmount\n\n```javascript\ncomponentWillUnmount(){\n  \n}\n```\n\n컴포넌트가 DOM 에서 사라진 후 실행되는 메소드,\n\n연결해두었던 이벤트 리스너를 제거하는 등의 수행을 하게 된다.\n\n\n\n\n\n\n\n---\n\n## References\n\n- https://velopert.com/1130\n- https://www.zerocho.com/category/React/post/579b5ec26958781500ed9955\n","fields":{"slug":"/js-react-lifecycle/"},"frontmatter":{"title":"리액트 생명주기 (React LifeCycle)","published":true}}},{"node":{"rawMarkdownBody":"\n스코프 = 현재 접근 할 수 있는 변수들의 범위  \n\n예제 1\n```html\n<button id=\"btn0\">버튼 1</button>\n<button id=\"btn1\">버튼 2</button>\n<button id=\"btn2\">버튼 3</button>\n\n<script>\n  var i, len = 3;\n  for (i = 0; i < len; i++) {\n    document.getElementById('btn'+i).addEventListener(\"click\", function () {\n      console.log(\"Click btn\", i);\n    });\n  }\n</script>\n```\n버튼 3개를 각각 클릭했을때 결과값은 모두 \"Click btn3\"가 나온다.  \n이벤트 핸들러의 콜백 함수가 작성되어 있는데 그 콜백 함수는 콜백함수 밖에 있는 변수들에 접근 할 수 있는 스코프를 가지게 된다.  \nfor 반복문을 통해서 각각 div 순서대로 클릭 이벤트 핸들러가 부여될 때 변수 i가 0부터 3까지 증가한 뒤 이후에 for 반복문이 끝나도 계속해서 유지된다.  \n따라서 나중에 출력문이 호출될때 변수 i의 값은 이미 for반복문이 끝난 값인 3으로 출력되는 것이다.  \n\nfor문을 돌때는 별도의 스코프가 생성되지 않고 i는 글로벌 스코프에 존재한다.  \n그러다가 **이벤트리스너의 콜백함수를 설정할때 익명 함수가 선언되면서 이때 스코프가 생성**되어 스코프 체인을 만들게 된다.\n\n이러한 현상은 **자바스크립트에서 스코프가 함수로 인해 생성되고 함수가 호출될 때도 계속 지속되어 변수들을 참조하는 특성**때문에 일어난다.  \n\n-----------\n\n스코프의 생성  \n\nfor문의 스코프 생성 여부를 알아보기 위한 예제  \n0부터 9까지 더하여 총합이 16이 넘는 숫자를 구하는 코드  \n```html\n<script>\n  for(var i = 0; i < 10; i++){\n    var total = (total || 0) + 1;\n    var last = i;\n    if(total > 16){\n      break;\n    }\n  }\n  console.log(\"typeof total !== 'undifined'\",typeof total !== \"undifined\");\n  console.log(\"typeof last !== 'undifined'\",typeof last !== \"undifined\");\n  console.log(\"typeof i !== 'undifined'\",typeof i !== \"undifined\");\n  console.log(\"total ===\"+total+\", last ===\"+last);\n</script>\n```\nConsole\n```\ntypeof total !== 'undifined' true\ntypeof last !== 'undifined' true\ntypeof i !== 'undifined' true\ntotal ===10, last ===9\n```\nfor문 안에서 생성된 변수 total,last,i가 정의되지 않은 것이 아니며, 값에 접근 할 수 있는 것을 알 수 있다.  \n\n다른 프로그래밍 언어에서는 for문 안에서 선언한 변수를 for문 밖에서 접근하게 되면 에러가 발생하지만  자바스크립트에서는 모든 값에 접근 할 수 있다.  \n이처럼 자바스크립트는 다른 언어와는 달리 일반적인 블록 스코프를 따르지 않는다.  \n**자바스크립트의 스코프는 특정 구문이 실행될 때 새로 생성하여 스코프 체인을 생성하게 된다.**   \n이렇게 스코프를 생성하는 구문들은 다음과 같다.  \n\n- function\n- with\n- catch  \n\n자바스크립트에서 이들의 사용법은 각각 다르지만, 중요한건 이런 구문들이 사용될 때문 스코프가 생성되고, **다른 프로그래밍 언어처럼 {}를 이용해 블록을 생성한다고 해서 스코프가 생성되는 것이 아니라는 점**이다.\n\n----------\n\nfunction 구문의 스코프 생성  \n\n```js\nfunction foo(){\n  var b = \"Can you access me?\";\n}\nconsole.log(typeof b === \"undefined\");\n```\nconsole\n```\ntrue\n```\nfunction foo안의 b값에 접근하지 못하는 것을 알 수 있다.    \n**function 구문을 통해서 스코프가 생성된 것을 알 수 있다.**  \n\n----------\n\ncatch 구문의 스코프 생성  \n\ncatch 구문도 스코프를 생성하기는 하지만 function과는 다른 동작을 보인다.  \n괄호 안에 인자로 받는 변수들만 새로운 내부 스코프에 포함되어 그 다음으로 오는 블록 안에서만 접근 할 수 있다.  \n반면 블록 안에서 새로 정의한 변수들은 for-loop와 비슷하게 블록 외부에서도 접근 할 수 있다.  \n```js\ntry {\n  throw new exception(\"fake exception\");\n} catch (error) {\n  var test = \"can you see me?\";\n  console.log(error instanceof ReferenceError === true);\n}\nconsole.log(test === \"can you see me?\");\nconsole.log(typeof error === undefined);\n```\nconsole\n```\ntrue\ntrue\nfalse\n```\n첫번째 출력문에서는 error라는 인자로 받은 변수가 해당 블록 안에 있는 것을 알 수 있다.  \n두번째 출력문에서는 catch 구문에서 **새로 정의한 test 변수에 접근이 가능**하다는 것을 알 수 있다.  \n세번째 출력문에서는 catch 구문에서 **인자로 받은 변수에는 접근이 불가능** 하다는 것을 알 수 있다.  \n\n----------\n\n엄밀하게 따져보면 스코프가 생성되는 방식이 기존 언어와 다르지 않다.  \n하지만 스코프가 지속되는 것은 다른 언어와는 다른 자바스크립트만의 강점 중 하나이다.  \n이러한 스코프의 지속성이 필요한 이유는 새로운 스코프가 생성되고  \n**스코프 체인을 참조하는 함수를 변수에도 넣을 수 있고**,  \n**다른 함수의 인자로 넘겨줄 수도 있으며**,  \n**함수의 반환값으로 이용할 수도 있기 때문이다**.  \n즉, 지금 함수가 선언된 곳이 아닌 전혀 다른 곳에서 함수가 호출 될 수 있어서, 해당 함수가 현재 참조하는 스코프를 지속할 필요가 있는 것이다.\n\n----------\n\n함수를 이용한 문제 해결  \n\n이러한 지속성을 이해하기 위해 앞의 클릭 이벤트 핸들러 문제를 또 다른 방식으로 해결해보자.  \n\n```html\n<button id=\"btn0\">버튼 1</button>\n<button id=\"btn1\">버튼 2</button>\n<button id=\"btn2\">버튼 3</button>\n<script>\n  var i, len = 3;\n\n  function setDiv(index) {\n    document.getElementById('btn' + index).addEventListener(\"click\", function () {\n      console.log(\"Click btn\", index);\n    });\n  }\n\n  for (i = 0; i < len; i++) {\n    setDiv(i);\n  }\n</script>\n```\n\nconsole\n\n```\nClick btn 0\nClick btn 1\nClick btn 2\n```\n\n이렇게 **함수로 분리하는 것은 비동기 처리를 많이 하는 자바스크립트의 특성에서는 중요하게 생각해야 하는 개발 방식**이다.  \n\n----------\n\n클로저를 이용한 문제 해결\n\n자바스크립트의 특징 중 하나인 클로저를 활용하여 이를 해결 할 수도 있다.\n\n```html\n  <button id=\"btn0\">버튼 1</button>\n  <button id=\"btn1\">버튼 2</button>\n  <button id=\"btn2\">버튼 3</button>\n  <script>\n    var i, len = 3;\n    /* 처음의 해결 전 코드\n    for (i = 0; i < len; i++) {\n      document.getElementById('btn'+i).addEventListener(\"click\", function () {\n        console.log(\"Click btn\", i);\n      });\n    }\n    */\n    for (i = 0; i < len; i++) {\n      document.getElementById('btn'+i).addEventListener(\"click\", (function(index) { //1\n        return function (){ //2\n          console.log(\"Click btn\", index);\n        };\n      }(i)));//3\n    }\n  </script>\n```\n\nconsole\n\n```\nClick btn 0\nClick btn 1\nClick btn 2\n```\n\n이벤트 리스너 실행 전 즉시 호출 함수 실행, 즉시 호출 함수 안의 함수가 반환된 값이 이벤트 리스너 함수의 두번째 인자로 들어간다.  \n1, 3은 즉시 호출 함수를 나타냄, 그리고 바로 다음 2는 index변수를 상위 스코프 체인에 추가한 뒤 addEventListener() 함수의 2번째 인자로 들어간다.  \n이벤트 리스너가 실행되기 전 먼저 즉시 호출 함수가 값을 반환받아 그 값이 이벤트 리스너의 2번째 인자로 작동하는 것.  \n\nglobal scope // i=2, len=3 <- function(index) // index = 0 <- btn0.click // empty scope  \nglobal scope // i=2, len=3 <- function(index) // index = 1 <- btn1.click // empty scope  \nglobal scope // i=2, len=3 <- function(index) // index = 2 <- btn2.click // empty scope  \n","fields":{"slug":"/js-scope/"},"frontmatter":{"title":"자바스크립트의 스코프(Scope)","published":true}}},{"node":{"rawMarkdownBody":"\n\nSPA(Single page application) 에서는 새로운 페이지 전체를 렌더링하지 않고, 부분적인 UI를 새로 렌더링한다.\n따라서 브라우저는 이 정보에 대한 이력을 남기지 않는다.\n결국 ''뒤로가기/앞으로가기''를 사용할 수 없다는 이야기이며,\n이는 사용자에게 당연시 되는 기능이므로 안된다면 많은 불편을 야기할 수 있다.\n그를 해결하기 위한 방법으로 React-router 라이브러리를 사용하게 된다.\n\n\n\n## install\n\n`npm install --save-dev react-router-dom`\n\n기존 v3 에서는 react-router 만 설치해서 사용하면 됐었다.\nv4에서는 브라우저와 react에서 사용되는 라우터가 분리되어 사용하도록 되어있다.\nReact-router-dom을 설치하면 react-router도 같이 설치된다.\n\n\n\n## Use\n\n### Basic \n\n상단의 헤더, 그 아래 컨텐츠가 나타나는 기본 구조.\n\n- src/App.js\n\n```react\n//..\nimport {BrowserRouter as Router, Route} from 'react-router-dom';\n\nimport Main from './routes/Main';\nimport User from './routes/User';\nimport Header from './components/Header';\nimport Posts from './routes/Posts';\n\nclass App extends Component {\n  render() {\n    return (\n      <Router>\n        <div>\n          <Header/>\n          <Route exact path=\"/\" component={Main}/>\n          <Route path=\"/user\" component={User}/>\n          <Route path=\"/posts\" component={Posts}\n          {/* exact 키워드가 없으면 /user 경로에서 /도 있는 것으로 인식, \n          Main과 User가 동시 출력 된다.*/}\n        </div>\n      </Router>\n    );\n  }\n}\n```\n\n\n\n- src/components/Header.js\n\n```react\n//..\n  return (\n    <div>\n    \t<Link to=\"/\">Home</Link>\n      \t<Link to=\"/User\">User</Link>\n    </div>\n  );\n```\n\n\n\n---\n\n\n\n### URL Parameter\n\n- src/App.js\n\n```react\n//..\n<Route path=\"/user/:username\" component={User}/>\n//..\n```\n\n\n\n- src/routes/User.js\n\n```react\n//..\nconst User = ({match}) => {\n  return (\n  \t<div> UserName is {match.params.username} </div>\n  );\n}\n```\n\n`…/user/baik` URL로 접속하면 UserName is baik 라는 것을 확인 할 수 있다.\n\n\n\n---\n\n\n\n### Route in Component\n\n- src/routes/Posts.js\n\n```react\n//..\n\nimport { Route, Link } from 'react-router-dom';\n\nconst Post = ({match}) => {\n  return (\n\t<div>\n    \t<h2>{match.params.title}</h2>\n    </div>\n  );\n}\n\nconst Posts = () => {\n  return (\n  \t<div>\n    \t<h1>Post</h1>\n      \t<Link to=\"/posts/react\">React</Link>\n      \t<Link to=\"/posts/redux\">Redux</Link>\n      \t<Route\n          \tpath=\"/posts/:title\"\n          \tcomponent={Post}\n          />\n    </div>\n  );\n}\n\nexports default Posts;\n```\n\n\n\n---\n\n\n\n### NavLink\n\n- src/components/Header.css\n\n```css\n.item.active {\n  \n}\n```\n\n- src/components/Header.js\n\n```react\n// <Link to ...></Link> => <NavLink to...></NavLink>\n\n<NavLink exact to=\"/\" className=\"item\" activeClassName=\"active\">Home</NavLink>\n\n{/* exact를 줘야 효과가 지난후에도 남아있지 않고 정확히 일치할때만 효과 적용 가능*/}\n```\n\n\n\n---\n\n\n\n### Redirect\n\n```react\nimport { Redirect } from 'react-router-dom';\n\nconst isLogin = false\n\n//..\nreturn (\n  <div>\t\n\t{!isLogin && <Redirect to=\"/login\"/>}\n    MyPage\n  </div>\n);\n```\n\n\n\n```react\nconst Main = ({history}) => {\n  return (\n  \t<div>\n    \t<button onClick={()=>{history.push('/posts')}}>포스트로 이동</button>\n    </div>\n  );\n}\n```\n\n\n\n---\n\n\n\n### Query Parameter\n\n```react\n//..\nconst Main = ({location}) => {\n  return (\n      <div>\n          {new URLSearchParams(location.search).get('keyword')} 검색\n      </div>\n  );\n}\n```\n\n\n\n---\n\n\n\n### Make NotFound Page\n\n- src/App.js\n\n```react\n//..\nimport {BrowserRouter as Router, Route, Switch} from 'react-router-dom';\n\n//..\nimport notFound from './routes/notFound';\n\nclass App extends Component {\n  render() {\n    return (\n      <Router>\n        <div>\n          <Header/>\n          \t<div>\n              <Switch>\n                <Route exact path=\"/\" component={Main}/>\n                <Route path=\"/user\" component={User}/>\n                <Route path=\"/posts\" component={Posts}/>\n                <Route component={notFound}/>\n              </Switch>\n            </div>\n        </div>\n      </Router>\n    );\n  }\n}\n```\n\nSwitch를 추가한다.\n\n기존 Switch가 없고, exact 조차 없을때는 Route 전체를 하나하나 비교해서 출력하나\n\nSwitch가 있으면 일치하는 것이 있으면 비교를 그만둔다, 끝까지 일치하는 것이 없으면 notFound 컴포넌트를 보여주게 된다.\n\n\n\n---\n\n## Reference\n\n- CodeSquad\n- https://velopert.com/3275\n","fields":{"slug":"/js-react-router-v4/"},"frontmatter":{"title":"리액트 라우터 V4 사용하기 (React-Router v4)","published":true}}},{"node":{"rawMarkdownBody":"\n```js\nvar user1 = {\n  name: 'user1',\n  say: function(){ console.log(this.name, \"-\", this) }\n}\nuser1.say(); //user1 - Object {name: \"user1\", say: function}\n/* user1의 this는 해당 user1 object를 가리킨다 */\n\nvar user = user1.say;\nuser(); //undefined - Window {...}\n/* user의 this는 window를 가리킨다, window.user()로 window에서 호출했기 때문 */\n\nvar user2 = {\n  name: 'user2',\n  say: user1.say\n}\nuser2.say(); //user2 - Object {name: \"user2\", say: function}\n/* user2의 say가 user1의 say의 내용이지만 this는 호출된 해당 user2 object이다 */\n\nuser2.say.call(user1); //user1 - Object {name: \"user1\", say: function}\n/* call과 apply 함수는 this를 자동적으로 만들어진 this가 아닌 지정한 this를 가리키도록 지정하는 것 */\n```\n\n\n\n**call(), apply()**\n\n두 함수는 function 객체의 기본 내장 함수이다.\n일반적으로 함수가 호출될 때는 내부적으로 call() 함수로 변형되어서 처리된다.\ncall과 apply 함수는 this를 자동적으로 만들어진 this가 아닌 지정한 this를 가리키도록 지정하는 것으로 첫번째 인자로 this를 지정하고 두번째 인자로는 함수의 인자를 지정한다.\ncall은 함수의 인자를 ','로 여러개를 넘기고 apply는 배열 한개로 넘긴다.\n\n\n\n---\n\n\n\n#### this의 이해\n\n일반적인 객체지향 언어와 달리 자바스크립트에서의 this는 조금 다르게 동작하는 경우가 많다.\n\n일반적인 상황에서 this가 어떻게 결정되는지 알려면 먼저 함수를 호출하는 방법에 대해 살펴봐야한다.\n\n\n\n자바스크립트에서 함수가 호출되는 방법은 다음 네가지가 주요하다.\n\n1. 일반 함수로의 호출\n   - ```js\n     function hello(name){\n       alert('hello', name);\n     }\n     hello('jhon');\n     ```\n\n2. 멤버함수로의 호출\n\n   - ```js\n     var hello = {\n       say : function(){\n         alert('hello');\n       }\n     }\n     hello.say();\n     ```\n\n3. call() 함수를 통한 호출\n\n   - ```js\n     function hello(name){\n       alert('hello', name);\n     }\n     hello.call(undefined, \"jhon\");\n     ```\n\n4. apply() 함수를 통한 호출\n\n   -  ```js\n      function hello(name){\n        alert('hello', name);\n      }\n      hello.apply(undefined, [\"jhon\"]);\n      ```\n\n\n\n\n```js\nfunction whatsThis(){\n  return this.toString();\n}\nvar user = {\n  what: whatsThis,\n  toString: function(){\n    return \"[objcet user]\"\n  }\n}\n\nwhatsThis(); \n//일반함수 \"[object Window]\"\n//글로벌 객체 window가 this로 설정되어있다.\n//일반적으로 함수가 호출될때는 내부적으로 call()함수로 변형되어 처리된다.\n//이때 call의 첫번째 인자는 undefined로 넘겨주어 this의 기본값으로 window가 되게 된다.\n\nuser.what(); \n//멤버함수 \"[objcet user]\"\n//이것또한 내부적으로 call함수로 변형되어 처리된다.\n//이때 call함수의 첫번째 인자로는 멤버함수를 보유한 객체(user)가 된다.\n//따라서 this는 user가 된다. \n//같은 함수라도 멤버함수가 호출되는 방법에 따라 this또한 변경되는 것이다.\n\nwhatsThis.call(); \n//call이용, 인자 없음 \"[object Window]\"\n\nwhatsThis.apply(user); \n//apply이용, 첫번째 인자 user\"[objcet user]\"\n\nuser.what.call(undefined) \n//멤버함수, call이용, 첫번째 인자 undefined \"[object Window]\"\n\nuser.what.call(user); \n//멤버함수, call이용, 첫번째 인자 user \"[objcet user]\"\n```\n\n\n\n**this는 함수나 스코프를 기반으로 결정되는 것이 나닌, 호출 방법에 따라 변경된다.**\n\n**콜백함수를 인자로 넘기는 등의 비동기적 방식의 호출이 많은 자바스크립트에서는 중요하게 생각해야한다.**","fields":{"slug":"/js-this/"},"frontmatter":{"title":"자바스크립트 this","published":true}}},{"node":{"rawMarkdownBody":"\n- 함수, 함수가 선언될 때의 environment로 구성  \n- 함수가 정의 될 때의 environment가 함께 closure로 결합되면서, 다양한 활용이 가능  \n\n```js\nfunction makeCounterFunction(initVal){\n    var count = initVal;\n    function Increase(){\n        count++;\n        console.log(count);\n    }\n    return Increase;\n}\n\nvar counter1 = makeCounterFunction(0);\nvar counter2 = makeCounterFunction(10);\n```\n- counter1의 closure\n    - 함수 : function Increase(){}\n    - 환경 : var count = 0;\n- counter2의 closure\n    - 함수 : function Increase(){}\n    - 환경 : var count = 10;\n여기서 counter1, counter2 함수가지고는 count 변수의 값을 직접 제어할 수 없다, count 변수는 makecounterfunction 안에 있고 여기선 increse함수밖에 없기때문이다. 이 원리를 이용해 private한 변수를 활용할 수 있다 아래서 확인해보자.\n\n---\n\n간단하게 클로저의 두가지 개념을 이해하도록 하자.  \n\n1) 외부 함수가 소멸된 뒤에도 내부 함수는 외부 함수의 지역 변수에 접근 할 수 있다.  \n2) 클로저를 이용하여 private한 변수를 만들 수 있다.  \n\n1번의 예\n```js\nfunction sum() {\n    var num = 0;\n    console.log(num);\n    function addsum() {\n        console.log(num);\n        num++;\n        return num;\n    }\n    return addsum;\n}\nvar a = sum(); \n// function addsum(){...}\n// 여기서 sum 함수는 수명이 끝남.\n\na();\n// 여기서 addsum()을 하게 되는 꼴인데,\n// num을 증가시키는 부분에서 num은 클로저에 담긴 num이다.\n// Closure(sum) num: 0\n\na();\n// Closure(sum) num: 1\n\na();\n// Closure(sum) num: 2\n```\n\n2번의 예\n```js\nfunction people(name) {\n    return {\n        get_name: function () {\n            console.log(name);\n            return name;\n        },\n        set_name: function (_name) {\n            console.log(name);\n            name = _name;\n        }\n    }\n}\nvar junho = people(\"junhobaik\"); \n//여기서 외부 함수의 인자로 값을 넘긴다.\n//함수에서는 전달 받은 값을 직접 조작할 수 없게 되고\n//get,set_name을 통해서만 접근 할 수 있게 된다.\n//이렇게 사용하는 방법으로 private한 변수를 만들 수 있다.\n\njunho.get_name(); \n//이때 실행되는 get_name의 console.log에서 name값은 closure(people) name:'junhobaik' 이다.\n```\n\n---\n\n### 추가 내용\n\n```html\n<button id=\"btn0\">버튼 1</button>\n<button id=\"btn1\">버튼 2</button>\n<button id=\"btn2\">버튼 3</button>\n<script> \n    for (var i = 0; i < 3; i++) {\n        document.getElementById('btn' + i).addEventListener(\"click\", function () {\n            console.log(\"Click btn\", i+1);\n        });\n    }\n</script>\n```\n기대하는 결과는 Click btn1,2,3 하지만 실제 결과는 Click btn3,3,3  \n그 이유는 아래와 같다.  \n1. for문을 돌며 버튼 1,2,3에 이벤트가 등록되며 콜백함수또한 등록된다. (여기서 위에서 살펴본 설명으로 이벤트는 외부함수, 콜백함수는 내부함수라고 할 수 있다)\n2. 이벤트가 등록되면서 이벤트 함수는 스택에서 떠난다 (소멸되었다)\n3. 따라서 콜백함수는 클로저 i값에 접근하게 되는데 클로저 i값은 콜백함수 모두가 공유하게 되는 값이다.\n4. for문을 통해 증가가 완료된 값이 클로저에 남아있고, 그 클로저 값이 계속해서 노출되는 것이다.\n\n해결 방법  \n1. let을 이용한 block scope 생성을 통한 해결\n2. 이벤트 함수(외부함수)를 또 함수로 묶어 새로운 scope를 만들어낸다.","fields":{"slug":"/js-clouser/"},"frontmatter":{"title":"자바스크립트 클로저(Closure)","published":true}}},{"node":{"rawMarkdownBody":"\n자바스크립트에서 모든 객체는 자신의 부모 객체와 연결 되어있다.  \n이것을 이용하여 객체지향에서 자식이 부모 객체의 요소를 가져다 쓸 수 있는 상속 개념을 사용할 수 있다.\n\n모든 객체는 자신을 생성한 생성자 함수의 prototype 프로퍼티가 가리키는 프로토타입 객체를 자신의 부모 객체로 설정하는 [[Prototype]] 프로퍼티로 연결한다. `[[Prototype]] Link`\n\n생성된 객체의 실제 부모 역활을 하는 건 생성자 자신이 아닌 생성자의 prototype 프로퍼티가 가리키는 프로토타입 객체이다.\n\n## Prototype?\n\n```js\nfunction Person(name){\n    this.name = name;\n}\nvar foo = new Person('foo');\n```\nPerson() 생성자는 prototype 프로퍼티로 자신과 링크된 프로토타입 객체(Person.prototype)를 가리킨다.  \n\nPerson() 생성자로 생성된 객체 foo는,  \nPerson() 함수의 프로토타입 객체를 [[Prototype]]Link로 연결한다.  \n\n\n### 프로토타입 체이닝\n특정 객체의 프로퍼티나 메서드에 접근하려 할 때, 해당 객체에 접근하려고 하는 프로퍼티나 메서드가 없다면 [[Prototype]]Link를 따라 자신의 부모 방향으로 프로토타입 객체의 프로퍼티를 차례대로 검사하는 것을 말한다.  \n즉, 프로토타입 체이닝을 통해 자신이 아닌 부모의 프로토타입 객체 프로퍼티에도 접근이 가능.  \n\n객체 리터럴로 생성한 객체는 Object()라는 내장 생성자 함수로 생성된 것으로,  \nObject가 갖고 있는 prototype 프로퍼티가 가리키는 프로토타입 객체인 Object.prototype 객체를 자신의 프로토타입 객체로 연결한다.\n\n\n```js\n//...위의 예제 코드...\nconsole.log(foo.hasOwnProperty('name'));\n```\n위의 예제 아래 이런 코드를 넣는다면 프로토타입 체이닝에 따라서 hasOwnProperty 메서드를 찾게 된다.  \n`foo > Person.prototype > Object.prototype.hasOwnProperty`\n\n\n프로토타입 또한 자바스크립트 객체이다. 함수가 생성될 때 자신의 prototype 프로퍼티에 연결되는 프로토타입 객체는 기본적으로 constructor 프로퍼티만을 가진 객체이다.  \n따라서 일반 객체처럼 동적으로 프로퍼티를 추가/삭제하는 것이 가능하다. 또한 변경된 프로퍼티는 프로토타입 체이닝에 항시 반영된다.\n\n```js\nfunction Person(name) {\n    this.name = name;\n}\n\nvar foo = new Person('foo');\n\nvar func = function() {console.log('hello');}\n\nPerson.prototype.sayHello = func;\nfoo.sayHello(); // Hello\n```\n---\n\nPrototype을 이용한 간단한 Todo list 예제\n\n```js\nvar toDoObj = { //이것을 변경하면 변경사항이 항시 반영되어 나타난다.\n  show: function () {\n    var listLength = this.toDoList.length;\n    for (var i = 0; i < listLength; i++) {\n      console.log('- ', this.toDoList[i]);\n    }\n  }\n  , add: function (task) {\n    this.toDoList.push(task);\n  }\n  , del: function (index) {\n    this.toDoList.splice(index, 1);\n  }\n}\n\nfunction toDo() {\n  this.toDoList = [];\n}\n\ntoDo.prototype = toDoObj; \n//todo 함수 객체의 프로토타입에 toDoObj를 추가해 \n//show,add,del을 프로퍼티를 사용할 수 있게 된다.\n//class toDo extends toDoObj {...}\n\nvar allTask = new toDo();\n//Object.setPrototypeOf(allTask,toDoObj);\n//toDo.prototype을 통해 todo() 생성자를 이용해 allTask라는 객체를 만들기 전에\n//todo.prototype = toDoObj를 하여 프로토타입을 추가하는 방법 대신에\n//object.setPrototypeOf를 사용하여 \n//allTask 객체에 toDoObj를 추가하는 방법 또한 있다.\n\nconsole.log(\"task 1~5 추가\");\nallTask.add(\"task 1\");\nallTask.add(\"task 2\");\nallTask.add(\"task 3\");\nallTask.add(\"task 4\");\nallTask.add(\"task 5\");\nallTask.show();\nconsole.log(\"\\n2,3 제거\");\nallTask.del(1);\nallTask.del(2);\nallTask.show();\n```\n\n\n---\n## References\n- [https://github.com/jsonko/dailyJavaScript/blob/171161c67ddcfb8dad369bb826e73cb5f4f93588/PrototypeChaining.md](https://github.com/jsonko/dailyJavaScript/blob/171161c67ddcfb8dad369bb826e73cb5f4f93588/PrototypeChaining.md)\n- [https://github.com/KyusungDev/JSStudy/blob/5167fba10310d2b177aa26be43fb0d3b2b831f8b/docs/books/inside_javascript/02.md](https://github.com/KyusungDev/JSStudy/blob/5167fba10310d2b177aa26be43fb0d3b2b831f8b/docs/books/inside_javascript/02.md)\n- [https://github.com/Lutece/sundayJavascript/blob/85d633268926261307ec18a3d4dad8c644e0c60f/inside_javascript/ch03/chapter03-04.md](https://github.com/Lutece/sundayJavascript/blob/85d633268926261307ec18a3d4dad8c644e0c60f/inside_javascript/ch03/chapter03-04.md)","fields":{"slug":"/js-prototype/"},"frontmatter":{"title":"자바스크립트 프로토타입(Prototype)","published":true}}}]}},"pageContext":{}}